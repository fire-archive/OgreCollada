/*
    Copyright (c) 2008 NetAllied Systems GmbH

    This file is part of COLLADASaxFrameworkLoader.

    Licensed under the MIT Open Source License,
    for details please see LICENSE file or the website
    http://www.opensource.org/licenses/mit-license.php
*/

#include "COLLADASaxFWLStableHeaders.h"
#include "GeneratedSaxParserUtils.h"

#include "COLLADASaxFWLColladaParserAutoGenPrivate.h"


namespace COLLADASaxFWL
{


//---------------------------------------------------------------------
const char* ColladaParserAutoGenPrivate::PARENT_CHILD_ELEMENT_SEPARATOR = "__";


//---------------------------------------------------------------------
ColladaParserAutoGenPrivate::ColladaParserAutoGenPrivate( COLLADASaxFWL::ColladaParserAutoGen* impl, GeneratedSaxParser::IErrorHandler* errorHandler
)    : GeneratedSaxParser::ParserTemplate<ColladaParserAutoGenPrivate, ColladaParserAutoGen>(impl, errorHandler)
{
    initFunctionMap();
    initNameMap();
}

//---------------------------------------------------------------------
ColladaParserAutoGenPrivate::~ColladaParserAutoGenPrivate()
{
}


//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES = "profile_GLES";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_ID = "id";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_PLATFORM = "platform";

//---------------------------------------------------------------------
const profile_GLES__AttributeData profile_GLES__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__AttributeData* attributeData = newData<profile_GLES__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET = "asset";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES__ASSET = "profile_GLES__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR = "contributor";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__CONTRIBUTOR = "asset__contributor";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__contributor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__contributor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__contributor()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__contributor( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AUTHOR = "author";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR__AUTHOR = "contributor__author";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__author( const ParserChar* text, size_t textLength )
{
return mImpl->data__author(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__author( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__author()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__author( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AUTHORING_TOOL = "authoring_tool";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR__AUTHORING_TOOL = "contributor__authoring_tool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__authoring_tool( const ParserChar* text, size_t textLength )
{
return mImpl->data__authoring_tool(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__authoring_tool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__authoring_tool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__authoring_tool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COMMENTS = "comments";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR__COMMENTS = "contributor__comments";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__comments( const ParserChar* text, size_t textLength )
{
return mImpl->data__comments(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__comments( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__comments()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__comments( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COPYRIGHT = "copyright";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR__COPYRIGHT = "contributor__copyright";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__copyright( const ParserChar* text, size_t textLength )
{
return mImpl->data__copyright(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__copyright( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__copyright()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__copyright( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE_DATA = "source_data";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTRIBUTOR__SOURCE_DATA = "contributor__source_data";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__source_data( const ParserChar* text, size_t textLength )
{
return mImpl->data__source_data(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__source_data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__source_data()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__source_data( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CREATED = "created";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__CREATED = "asset__created";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__created( const ParserChar* text, size_t textLength )
{
return mImpl->data__created(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__created( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__created()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__created( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_KEYWORDS = "keywords";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__KEYWORDS = "asset__keywords";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__keywords( const ParserChar* text, size_t textLength )
{
return mImpl->data__keywords(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__keywords( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__keywords()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__keywords( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MODIFIED = "modified";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__MODIFIED = "asset__modified";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__modified( const ParserChar* text, size_t textLength )
{
return mImpl->data__modified(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__modified( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__modified()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__modified( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REVISION = "revision";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__REVISION = "asset__revision";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__revision( const ParserChar* text, size_t textLength )
{
return mImpl->data__revision(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__revision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__revision()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__revision( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SUBJECT = "subject";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__SUBJECT = "asset__subject";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__subject( const ParserChar* text, size_t textLength )
{
return mImpl->data__subject(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__subject( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__subject()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__subject( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TITLE = "title";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__TITLE = "asset__title";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__title( const ParserChar* text, size_t textLength )
{
return mImpl->data__title(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__title( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__title()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__title( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_UNIT = "unit";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__UNIT = "asset__unit";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_METER = "meter";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_NAME = "name";

//---------------------------------------------------------------------
const unit__AttributeData unit__AttributeData::DEFAULT = {1.0E0, (const GeneratedSaxParser::ParserChar *)"meter"};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
unit__AttributeData* attributeData = newData<unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METER:
    {
bool failed;
attributeData->meter = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_UNIT, HASH_ATTRIBUTE_METER, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_UNIT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__unit()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__unit( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_UP_AXIS = "up_axis";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASSET__UP_AXIS = "asset__up_axis";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__up_axis( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__up_axis( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__up_axis()
{
bool failed;
UpAxisType parameter = Utils::toEnum<UpAxisType, StringHash, UpAxisType__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, UpAxisTypeMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__up_axis(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_UP_AXIS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__up_axis( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
UpAxisType ColladaParserAutoGenPrivate::toEnumDataPrefix_UpAxisType (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, UpAxisType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<UpAxisType, StringHash, UpAxisType__COUNT, &toEnum_UpAxisType>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_UpAxisType (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const UpAxisType*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<UpAxisType, StringHash, UpAxisType__COUNT>(text, textLength, dataFunction, UpAxisTypeMap, baseConversionFunc, &toEnum_UpAxisType, &ColladaParserAutoGenPrivate::toEnumDataPrefix_UpAxisType);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_UpAxisType (
    bool ( ColladaParserAutoGen::*dataFunction )(const UpAxisType*, size_t ),
    const std::pair<StringHash, UpAxisType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    UpAxisType (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, UpAxisType>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<UpAxisType, StringHash, UpAxisType__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGE = "image";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES__IMAGE = "profile_GLES__image";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_FORMAT = "format";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_HEIGHT = "height";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_WIDTH = "width";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_DEPTH = "depth";

//---------------------------------------------------------------------
const image__AttributeData image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, 1};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGE__ASSET = "image__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__image__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__image__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__image__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__image__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DATA = "data";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGE__DATA = "image__data";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__data( const ParserChar* text, size_t textLength )
{
return mImpl->data__data(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__data()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__data( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_FROM = "init_from";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGE__INIT_FROM = "image__init_from";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__image__init_from( const ParserChar* text, size_t textLength )
{
return mImpl->data__image__init_from(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__image__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__image__init_from()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__image__init_from( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EXTRA = "extra";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGE__EXTRA = "image__extra";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_TYPE = "type";

//---------------------------------------------------------------------
const extra__AttributeData extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__image__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__image__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IMAGE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__image__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__image__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EXTRA__ASSET = "extra__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__extra__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__extra__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__extra__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__extra__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE = "technique";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EXTRA__TECHNIQUE = "extra__technique";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_PROFILE = "profile";

//---------------------------------------------------------------------
const extra__technique__AttributeData extra__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__extra__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__extra__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__technique__AttributeData* attributeData = newData<extra__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EXTRA__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__extra__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__extra__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM = "newparam";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES__NEWPARAM = "profile_GLES__newparam";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SID = "sid";

//---------------------------------------------------------------------
const profile_GLES__newparam__AttributeData profile_GLES__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__newparam__AttributeData* attributeData = newData<profile_GLES__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE = "annotate";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__ANNOTATE = "newparam__annotate";

//---------------------------------------------------------------------
const annotate__AttributeData annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL = "bool";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__BOOL = "annotate__bool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__annotate__bool(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANNOTATE__BOOL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL2 = "bool2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__BOOL2 = "annotate__bool2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__bool2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool2()
{
return boolDataEnd( &ColladaParserAutoGen::data__annotate__bool2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL3 = "bool3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__BOOL3 = "annotate__bool3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__bool3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool3()
{
return boolDataEnd( &ColladaParserAutoGen::data__annotate__bool3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL4 = "bool4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__BOOL4 = "annotate__bool4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__bool4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool4()
{
return boolDataEnd( &ColladaParserAutoGen::data__annotate__bool4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT = "int";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__INT = "annotate__int";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__int( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__annotate__int(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANNOTATE__INT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__int( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT2 = "int2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__INT2 = "annotate__int2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__int2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__annotate__int2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int2()
{
return longDataEnd( &ColladaParserAutoGen::data__annotate__int2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT3 = "int3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__INT3 = "annotate__int3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__int3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__annotate__int3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int3()
{
return longDataEnd( &ColladaParserAutoGen::data__annotate__int3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT4 = "int4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__INT4 = "annotate__int4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__int4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__annotate__int4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int4()
{
return longDataEnd( &ColladaParserAutoGen::data__annotate__int4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT = "float";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT = "annotate__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__annotate__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANNOTATE__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT2 = "float2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT2 = "annotate__float2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT3 = "float3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT3 = "annotate__float3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT4 = "float4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT4 = "annotate__float4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT2X2 = "float2x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT2X2 = "annotate__float2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT3X3 = "float3x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT3X3 = "annotate__float3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT4X4 = "float4x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__FLOAT4X4 = "annotate__float4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__float4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__annotate__float4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STRING = "string";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANNOTATE__STRING = "annotate__string";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__annotate__string( const ParserChar* text, size_t textLength )
{
return mImpl->data__annotate__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__annotate__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__annotate__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__annotate__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SEMANTIC = "semantic";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SEMANTIC = "newparam__semantic";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__semantic( const ParserChar* text, size_t textLength )
{
return mImpl->data__semantic(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__semantic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__semantic()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__semantic( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MODIFIER = "modifier";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__MODIFIER = "newparam__modifier";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__modifier( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__modifier( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__modifier()
{
bool failed;
fx_modifier_enum_common parameter = Utils::toEnum<fx_modifier_enum_common, StringHash, fx_modifier_enum_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_modifier_enum_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__modifier(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MODIFIER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__modifier( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_modifier_enum_common ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_modifier_enum_common (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_modifier_enum_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_modifier_enum_common, StringHash, fx_modifier_enum_common__COUNT, &toEnum_fx_modifier_enum_common>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_modifier_enum_common (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_modifier_enum_common*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_modifier_enum_common, StringHash, fx_modifier_enum_common__COUNT>(text, textLength, dataFunction, fx_modifier_enum_commonMap, baseConversionFunc, &toEnum_fx_modifier_enum_common, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_modifier_enum_common);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_modifier_enum_common (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_modifier_enum_common*, size_t ),
    const std::pair<StringHash, fx_modifier_enum_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_modifier_enum_common (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_modifier_enum_common>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_modifier_enum_common, StringHash, fx_modifier_enum_common__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL = "newparam__bool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__bool(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__BOOL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL2 = "newparam__bool2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL3 = "newparam__bool3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL4 = "newparam__bool4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT = "newparam__int";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__int(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__INT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT2 = "newparam__int2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT3 = "newparam__int3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT4 = "newparam__int4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT = "newparam__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT2 = "newparam__float2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT3 = "newparam__float3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT4 = "newparam__float4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT1X1 = "float1x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT1X1 = "newparam__float1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float1x1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__float1x1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__FLOAT1X1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT1X2 = "float1x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT1X2 = "newparam__float1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT1X3 = "float1x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT1X3 = "newparam__float1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT1X4 = "float1x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT1X4 = "newparam__float1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT2X1 = "float2x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT2X1 = "newparam__float2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT2X2 = "newparam__float2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT2X3 = "float2x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT2X3 = "newparam__float2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT2X4 = "float2x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT2X4 = "newparam__float2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT3X1 = "float3x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT3X1 = "newparam__float3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT3X2 = "float3x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT3X2 = "newparam__float3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT3X3 = "newparam__float3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT3X4 = "float3x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT3X4 = "newparam__float3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT4X1 = "float4x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT4X1 = "newparam__float4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT4X2 = "float4x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT4X2 = "newparam__float4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT4X3 = "float4x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT4X3 = "newparam__float4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT4X4 = "newparam__float4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__float4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE = "surface";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SURFACE = "newparam__surface";

//---------------------------------------------------------------------
const newparam__surface__AttributeData newparam__surface__AttributeData::DEFAULT = {fx_surface_type_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__surface__AttributeData* attributeData = newData<newparam__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(attributeValue, failed, fx_surface_type_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__SURFACE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__SURFACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_type_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_type_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_type_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT, &toEnum_fx_surface_type_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_type_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_type_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(text, textLength, dataFunction, fx_surface_type_enumMap, baseConversionFunc, &toEnum_fx_surface_type_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_type_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_type_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_type_enum*, size_t ),
    const std::pair<StringHash, fx_surface_type_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_type_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_type_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_AS_NULL = "init_as_null";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_AS_NULL = "surface__init_as_null";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_as_null( const ParserChar* text, size_t textLength )
{
return mImpl->data__init_as_null(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_as_null( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_as_null()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_as_null( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_AS_TARGET = "init_as_target";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_AS_TARGET = "surface__init_as_target";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_as_target( const ParserChar* text, size_t textLength )
{
return mImpl->data__init_as_target(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_as_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_as_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_as_target( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_CUBE = "init_cube";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_CUBE = "surface__init_cube";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_cube( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_cube( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_cube()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_cube( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALL = "all";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_CUBE__ALL = "init_cube__all";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_REF = "ref";

//---------------------------------------------------------------------
const init_cube__all__AttributeData init_cube__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_cube__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__all__AttributeData* attributeData = newData<init_cube__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_CUBE__ALL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__all()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_cube__all( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PRIMARY = "primary";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_CUBE__PRIMARY = "init_cube__primary";

//---------------------------------------------------------------------
const init_cube__primary__AttributeData init_cube__primary__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_cube__primary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__primary__AttributeData* attributeData = newData<init_cube__primary__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_CUBE__PRIMARY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__primary()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_cube__primary( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORDER = "order";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PRIMARY__ORDER = "primary__order";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__order( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__order( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__order()
{
bool failed;
fx_surface_face_enum parameter = Utils::toEnum<fx_surface_face_enum, StringHash, fx_surface_face_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_surface_face_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__order(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ORDER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__order( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_face_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_face_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_face_enum, StringHash, fx_surface_face_enum__COUNT, &toEnum_fx_surface_face_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_face_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_face_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_face_enum, StringHash, fx_surface_face_enum__COUNT>(text, textLength, dataFunction, fx_surface_face_enumMap, baseConversionFunc, &toEnum_fx_surface_face_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_face_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_face_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_face_enum*, size_t ),
    const std::pair<StringHash, fx_surface_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_face_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_face_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_face_enum, StringHash, fx_surface_face_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FACE = "face";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_CUBE__FACE = "init_cube__face";

//---------------------------------------------------------------------
const init_cube__face__AttributeData init_cube__face__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_cube__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__face__AttributeData* attributeData = newData<init_cube__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_CUBE__FACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__face()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_cube__face( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_VOLUME = "init_volume";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_VOLUME = "surface__init_volume";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_volume( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_volume( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_volume()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_volume( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_VOLUME__ALL = "init_volume__all";

//---------------------------------------------------------------------
const init_volume__all__AttributeData init_volume__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_volume__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_volume__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_volume__all__AttributeData* attributeData = newData<init_volume__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_VOLUME__ALL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_volume__all()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_volume__all( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_VOLUME__PRIMARY = "init_volume__primary";

//---------------------------------------------------------------------
const init_volume__primary__AttributeData init_volume__primary__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_volume__primary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_volume__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_volume__primary__AttributeData* attributeData = newData<init_volume__primary__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_VOLUME__PRIMARY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_volume__primary()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_volume__primary( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_PLANAR = "init_planar";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_PLANAR = "surface__init_planar";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_planar( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_planar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_planar()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_planar( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INIT_PLANAR__ALL = "init_planar__all";

//---------------------------------------------------------------------
const init_planar__all__AttributeData init_planar__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__init_planar__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__init_planar__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_planar__all__AttributeData* attributeData = newData<init_planar__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_PLANAR__ALL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__init_planar__all()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__init_planar__all( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__INIT_FROM = "surface__init_from";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_MIP = "mip";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SLICE = "slice";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_FACE = "face";

//---------------------------------------------------------------------
const surface__init_from__AttributeData surface__init_from__AttributeData::DEFAULT = {0, 0, fx_surface_face_enum__POSITIVE_X};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__surface__init_from( const ParserChar* text, size_t textLength )
{
return mImpl->data__surface__init_from(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__surface__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
surface__init_from__AttributeData* attributeData = newData<surface__init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_MIP:
    {
bool failed;
attributeData->mip = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_MIP, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SLICE:
    {
bool failed;
attributeData->slice = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_SLICE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_FACE:
    {
bool failed;
attributeData->face = Utils::toEnum<fx_surface_face_enum, StringHash, fx_surface_face_enum__COUNT>(attributeValue, failed, fx_surface_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_FACE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SURFACE__INIT_FROM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__surface__init_from()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__surface__init_from( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT = "format";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__FORMAT = "surface__format";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__format( const ParserChar* text, size_t textLength )
{
return mImpl->data__format(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__format()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__format( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT = "format_hint";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__FORMAT_HINT = "surface__format_hint";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__format_hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__format_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__format_hint()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__format_hint( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CHANNELS = "channels";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT__CHANNELS = "format_hint__channels";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__channels( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__channels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__channels()
{
bool failed;
fx_surface_format_hint_channels_enum parameter = Utils::toEnum<fx_surface_format_hint_channels_enum, StringHash, fx_surface_format_hint_channels_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_surface_format_hint_channels_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__channels(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_CHANNELS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__channels( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_format_hint_channels_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_channels_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_format_hint_channels_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_format_hint_channels_enum, StringHash, fx_surface_format_hint_channels_enum__COUNT, &toEnum_fx_surface_format_hint_channels_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_format_hint_channels_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_channels_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_format_hint_channels_enum, StringHash, fx_surface_format_hint_channels_enum__COUNT>(text, textLength, dataFunction, fx_surface_format_hint_channels_enumMap, baseConversionFunc, &toEnum_fx_surface_format_hint_channels_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_channels_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_format_hint_channels_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_channels_enum*, size_t ),
    const std::pair<StringHash, fx_surface_format_hint_channels_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_format_hint_channels_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_format_hint_channels_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_format_hint_channels_enum, StringHash, fx_surface_format_hint_channels_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RANGE = "range";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT__RANGE = "format_hint__range";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__range( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__range()
{
bool failed;
fx_surface_format_hint_range_enum parameter = Utils::toEnum<fx_surface_format_hint_range_enum, StringHash, fx_surface_format_hint_range_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_surface_format_hint_range_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__range(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_RANGE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__range( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_format_hint_range_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_range_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_format_hint_range_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_format_hint_range_enum, StringHash, fx_surface_format_hint_range_enum__COUNT, &toEnum_fx_surface_format_hint_range_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_format_hint_range_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_range_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_format_hint_range_enum, StringHash, fx_surface_format_hint_range_enum__COUNT>(text, textLength, dataFunction, fx_surface_format_hint_range_enumMap, baseConversionFunc, &toEnum_fx_surface_format_hint_range_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_range_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_format_hint_range_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_range_enum*, size_t ),
    const std::pair<StringHash, fx_surface_format_hint_range_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_format_hint_range_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_format_hint_range_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_format_hint_range_enum, StringHash, fx_surface_format_hint_range_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PRECISION = "precision";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT__PRECISION = "format_hint__precision";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__precision( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__precision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__precision()
{
bool failed;
fx_surface_format_hint_precision_enum parameter = Utils::toEnum<fx_surface_format_hint_precision_enum, StringHash, fx_surface_format_hint_precision_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_surface_format_hint_precision_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__precision(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_PRECISION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__precision( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_format_hint_precision_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_precision_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_format_hint_precision_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_format_hint_precision_enum, StringHash, fx_surface_format_hint_precision_enum__COUNT, &toEnum_fx_surface_format_hint_precision_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_format_hint_precision_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_precision_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_format_hint_precision_enum, StringHash, fx_surface_format_hint_precision_enum__COUNT>(text, textLength, dataFunction, fx_surface_format_hint_precision_enumMap, baseConversionFunc, &toEnum_fx_surface_format_hint_precision_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_precision_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_format_hint_precision_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_precision_enum*, size_t ),
    const std::pair<StringHash, fx_surface_format_hint_precision_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_format_hint_precision_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_format_hint_precision_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_format_hint_precision_enum, StringHash, fx_surface_format_hint_precision_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_OPTION = "option";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT__OPTION = "format_hint__option";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__option( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__option( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__option()
{
bool failed;
fx_surface_format_hint_option_enum parameter = Utils::toEnum<fx_surface_format_hint_option_enum, StringHash, fx_surface_format_hint_option_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_surface_format_hint_option_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__option(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_OPTION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__option( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_surface_format_hint_option_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_option_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_surface_format_hint_option_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_surface_format_hint_option_enum, StringHash, fx_surface_format_hint_option_enum__COUNT, &toEnum_fx_surface_format_hint_option_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_surface_format_hint_option_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_option_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_surface_format_hint_option_enum, StringHash, fx_surface_format_hint_option_enum__COUNT>(text, textLength, dataFunction, fx_surface_format_hint_option_enumMap, baseConversionFunc, &toEnum_fx_surface_format_hint_option_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_surface_format_hint_option_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_surface_format_hint_option_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_surface_format_hint_option_enum*, size_t ),
    const std::pair<StringHash, fx_surface_format_hint_option_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_surface_format_hint_option_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_surface_format_hint_option_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_surface_format_hint_option_enum, StringHash, fx_surface_format_hint_option_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORMAT_HINT__EXTRA = "format_hint__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__format_hint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__format_hint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORMAT_HINT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__format_hint__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__format_hint__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SIZE = "size";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__SIZE = "surface__size";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__surface__size( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__surface__size);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__surface__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__surface__size()
{
return longDataEnd( &ColladaParserAutoGen::data__surface__size );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__surface__size( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VIEWPORT_RATIO = "viewport_ratio";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__VIEWPORT_RATIO = "surface__viewport_ratio";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__viewport_ratio( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__viewport_ratio);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__viewport_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__viewport_ratio()
{
return doubleDataEnd( &ColladaParserAutoGen::data__viewport_ratio );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__viewport_ratio( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIP_LEVELS = "mip_levels";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__MIP_LEVELS = "surface__mip_levels";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mip_levels( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mip_levels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mip_levels()
{
bool failed;
unsigned long parameter = GeneratedSaxParser::Utils::toUnsignedLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__mip_levels(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIP_LEVELS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mip_levels( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIPMAP_GENERATE = "mipmap_generate";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__MIPMAP_GENERATE = "surface__mipmap_generate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mipmap_generate( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mipmap_generate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mipmap_generate()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__mipmap_generate(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIPMAP_GENERATE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mipmap_generate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__EXTRA = "surface__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__surface__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__surface__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SURFACE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__surface__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__surface__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE = "texture_pipeline";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__TEXTURE_PIPELINE = "newparam__texture_pipeline";

//---------------------------------------------------------------------
const newparam__texture_pipeline__AttributeData newparam__texture_pipeline__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__texture_pipeline__AttributeData* attributeData = newData<newparam__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__TEXTURE_PIPELINE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__texture_pipeline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXCOMBINER = "texcombiner";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE__TEXCOMBINER = "texture_pipeline__texcombiner";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_pipeline__texcombiner( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__texcombiner()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_pipeline__texcombiner( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT = "constant";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXCOMBINER__CONSTANT = "texcombiner__constant";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_VALUE = "value";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_PARAM = "param";

//---------------------------------------------------------------------
const texcombiner__constant__AttributeData texcombiner__constant__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texcombiner__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texcombiner__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcombiner__constant__AttributeData* attributeData = newData<texcombiner__constant__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__CONSTANT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXCOMBINER__CONSTANT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texcombiner__constant()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texcombiner__constant( void* attributeData )
{
    texcombiner__constant__AttributeData* typedAttributeData = static_cast<texcombiner__constant__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RGB = "RGB";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXCOMBINER__RGB = "texcombiner__RGB";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE__OPERATOR = "_operator";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SCALE = "scale";

//---------------------------------------------------------------------
const RGB__AttributeData RGB__AttributeData::DEFAULT = {gles_texcombiner_operatorRGB_enums__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__RGB( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__RGB( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
RGB__AttributeData* attributeData = newData<RGB__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<gles_texcombiner_operatorRGB_enums, StringHash, gles_texcombiner_operatorRGB_enums__COUNT>(attributeValue, failed, gles_texcombiner_operatorRGB_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB, HASH_ATTRIBUTE__OPERATOR, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB, HASH_ATTRIBUTE_SCALE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RGB, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__RGB()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__RGB( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_texcombiner_operatorRGB_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operatorRGB_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texcombiner_operatorRGB_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texcombiner_operatorRGB_enums, StringHash, gles_texcombiner_operatorRGB_enums__COUNT, &toEnum_gles_texcombiner_operatorRGB_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texcombiner_operatorRGB_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operatorRGB_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texcombiner_operatorRGB_enums, StringHash, gles_texcombiner_operatorRGB_enums__COUNT>(text, textLength, dataFunction, gles_texcombiner_operatorRGB_enumsMap, baseConversionFunc, &toEnum_gles_texcombiner_operatorRGB_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operatorRGB_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texcombiner_operatorRGB_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operatorRGB_enums*, size_t ),
    const std::pair<StringHash, gles_texcombiner_operatorRGB_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texcombiner_operatorRGB_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texcombiner_operatorRGB_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texcombiner_operatorRGB_enums, StringHash, gles_texcombiner_operatorRGB_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARGUMENT = "argument";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RGB__ARGUMENT = "RGB__argument";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SOURCE = "source";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_OPERAND = "operand";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_UNIT = "unit";

//---------------------------------------------------------------------
const RGB__argument__AttributeData RGB__argument__AttributeData::DEFAULT = {gles_texcombiner_source_enums__NOT_PRESENT, gles_texcombiner_operandRGB_enums__SRC_COLOR, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__RGB__argument( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__RGB__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
RGB__argument__AttributeData* attributeData = newData<RGB__argument__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = Utils::toEnum<gles_texcombiner_source_enums, StringHash, gles_texcombiner_source_enums__COUNT>(attributeValue, failed, gles_texcombiner_source_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB__ARGUMENT, HASH_ATTRIBUTE_SOURCE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {
bool failed;
attributeData->operand = Utils::toEnum<gles_texcombiner_operandRGB_enums, StringHash, gles_texcombiner_operandRGB_enums__COUNT>(attributeValue, failed, gles_texcombiner_operandRGB_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB__ARGUMENT, HASH_ATTRIBUTE_OPERAND, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RGB__ARGUMENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__RGB__argument()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__RGB__argument( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_texcombiner_source_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_source_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texcombiner_source_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texcombiner_source_enums, StringHash, gles_texcombiner_source_enums__COUNT, &toEnum_gles_texcombiner_source_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texcombiner_source_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_source_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texcombiner_source_enums, StringHash, gles_texcombiner_source_enums__COUNT>(text, textLength, dataFunction, gles_texcombiner_source_enumsMap, baseConversionFunc, &toEnum_gles_texcombiner_source_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_source_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texcombiner_source_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_source_enums*, size_t ),
    const std::pair<StringHash, gles_texcombiner_source_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texcombiner_source_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texcombiner_source_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texcombiner_source_enums, StringHash, gles_texcombiner_source_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
gles_texcombiner_operandRGB_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operandRGB_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texcombiner_operandRGB_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texcombiner_operandRGB_enums, StringHash, gles_texcombiner_operandRGB_enums__COUNT, &toEnum_gles_texcombiner_operandRGB_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texcombiner_operandRGB_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operandRGB_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texcombiner_operandRGB_enums, StringHash, gles_texcombiner_operandRGB_enums__COUNT>(text, textLength, dataFunction, gles_texcombiner_operandRGB_enumsMap, baseConversionFunc, &toEnum_gles_texcombiner_operandRGB_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operandRGB_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texcombiner_operandRGB_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operandRGB_enums*, size_t ),
    const std::pair<StringHash, gles_texcombiner_operandRGB_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texcombiner_operandRGB_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texcombiner_operandRGB_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texcombiner_operandRGB_enums, StringHash, gles_texcombiner_operandRGB_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA = "alpha";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXCOMBINER__ALPHA = "texcombiner__alpha";

//---------------------------------------------------------------------
const texcombiner__alpha__AttributeData texcombiner__alpha__AttributeData::DEFAULT = {gles_texcombiner_operatorAlpha_enums__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texcombiner__alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texcombiner__alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcombiner__alpha__AttributeData* attributeData = newData<texcombiner__alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<gles_texcombiner_operatorAlpha_enums, StringHash, gles_texcombiner_operatorAlpha_enums__COUNT>(attributeValue, failed, gles_texcombiner_operatorAlpha_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA, HASH_ATTRIBUTE__OPERATOR, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA, HASH_ATTRIBUTE_SCALE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXCOMBINER__ALPHA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texcombiner__alpha()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texcombiner__alpha( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_texcombiner_operatorAlpha_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operatorAlpha_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texcombiner_operatorAlpha_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texcombiner_operatorAlpha_enums, StringHash, gles_texcombiner_operatorAlpha_enums__COUNT, &toEnum_gles_texcombiner_operatorAlpha_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texcombiner_operatorAlpha_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operatorAlpha_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texcombiner_operatorAlpha_enums, StringHash, gles_texcombiner_operatorAlpha_enums__COUNT>(text, textLength, dataFunction, gles_texcombiner_operatorAlpha_enumsMap, baseConversionFunc, &toEnum_gles_texcombiner_operatorAlpha_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operatorAlpha_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texcombiner_operatorAlpha_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operatorAlpha_enums*, size_t ),
    const std::pair<StringHash, gles_texcombiner_operatorAlpha_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texcombiner_operatorAlpha_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texcombiner_operatorAlpha_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texcombiner_operatorAlpha_enums, StringHash, gles_texcombiner_operatorAlpha_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA__ARGUMENT = "alpha__argument";

//---------------------------------------------------------------------
const alpha__argument__AttributeData alpha__argument__AttributeData::DEFAULT = {gles_texcombiner_source_enums__NOT_PRESENT, gles_texcombiner_operandAlpha_enums__SRC_ALPHA, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__alpha__argument( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__alpha__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha__argument__AttributeData* attributeData = newData<alpha__argument__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = Utils::toEnum<gles_texcombiner_source_enums, StringHash, gles_texcombiner_source_enums__COUNT>(attributeValue, failed, gles_texcombiner_source_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA__ARGUMENT, HASH_ATTRIBUTE_SOURCE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {
bool failed;
attributeData->operand = Utils::toEnum<gles_texcombiner_operandAlpha_enums, StringHash, gles_texcombiner_operandAlpha_enums__COUNT>(attributeValue, failed, gles_texcombiner_operandAlpha_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA__ARGUMENT, HASH_ATTRIBUTE_OPERAND, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA__ARGUMENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__alpha__argument()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__alpha__argument( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_texcombiner_operandAlpha_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operandAlpha_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texcombiner_operandAlpha_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texcombiner_operandAlpha_enums, StringHash, gles_texcombiner_operandAlpha_enums__COUNT, &toEnum_gles_texcombiner_operandAlpha_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texcombiner_operandAlpha_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operandAlpha_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texcombiner_operandAlpha_enums, StringHash, gles_texcombiner_operandAlpha_enums__COUNT>(text, textLength, dataFunction, gles_texcombiner_operandAlpha_enumsMap, baseConversionFunc, &toEnum_gles_texcombiner_operandAlpha_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texcombiner_operandAlpha_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texcombiner_operandAlpha_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texcombiner_operandAlpha_enums*, size_t ),
    const std::pair<StringHash, gles_texcombiner_operandAlpha_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texcombiner_operandAlpha_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texcombiner_operandAlpha_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texcombiner_operandAlpha_enums, StringHash, gles_texcombiner_operandAlpha_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXENV = "texenv";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE__TEXENV = "texture_pipeline__texenv";

//---------------------------------------------------------------------
const texenv__AttributeData texenv__AttributeData::DEFAULT = {gles_texenv_mode_enums__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_pipeline__texenv( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texenv__AttributeData* attributeData = newData<texenv__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<gles_texenv_mode_enums, StringHash, gles_texenv_mode_enums__COUNT>(attributeValue, failed, gles_texenv_mode_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__TEXENV, HASH_ATTRIBUTE__OPERATOR, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_PIPELINE__TEXENV, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__texenv()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_pipeline__texenv( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_texenv_mode_enums ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texenv_mode_enums (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_texenv_mode_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_texenv_mode_enums, StringHash, gles_texenv_mode_enums__COUNT, &toEnum_gles_texenv_mode_enums>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_texenv_mode_enums (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texenv_mode_enums*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_texenv_mode_enums, StringHash, gles_texenv_mode_enums__COUNT>(text, textLength, dataFunction, gles_texenv_mode_enumsMap, baseConversionFunc, &toEnum_gles_texenv_mode_enums, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_texenv_mode_enums);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_texenv_mode_enums (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_texenv_mode_enums*, size_t ),
    const std::pair<StringHash, gles_texenv_mode_enums>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_texenv_mode_enums (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_texenv_mode_enums>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_texenv_mode_enums, StringHash, gles_texenv_mode_enums__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXENV__CONSTANT = "texenv__constant";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texenv__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texenv__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texenv__constant__AttributeData* attributeData = newData<texenv__constant__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXENV__CONSTANT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXENV__CONSTANT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texenv__constant()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texenv__constant( void* attributeData )
{
    texenv__constant__AttributeData* typedAttributeData = static_cast<texenv__constant__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE__EXTRA = "texture_pipeline__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_pipeline__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_PIPELINE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_pipeline__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE = "sampler_state";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLER_STATE = "newparam__sampler_state";

//---------------------------------------------------------------------
const newparam__sampler_state__AttributeData newparam__sampler_state__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__sampler_state( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__sampler_state__AttributeData* attributeData = newData<newparam__sampler_state__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__SAMPLER_STATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__sampler_state( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_WRAP_S = "wrap_s";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__WRAP_S = "sampler_state__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__wrap_s()
{
bool failed;
gles_sampler_wrap parameter = Utils::toEnum<gles_sampler_wrap, StringHash, gles_sampler_wrap__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, gles_sampler_wrapMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_sampler_wrap ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_sampler_wrap (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_sampler_wrap>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_sampler_wrap, StringHash, gles_sampler_wrap__COUNT, &toEnum_gles_sampler_wrap>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_sampler_wrap (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_sampler_wrap*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_sampler_wrap, StringHash, gles_sampler_wrap__COUNT>(text, textLength, dataFunction, gles_sampler_wrapMap, baseConversionFunc, &toEnum_gles_sampler_wrap, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_sampler_wrap);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_sampler_wrap (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_sampler_wrap*, size_t ),
    const std::pair<StringHash, gles_sampler_wrap>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_sampler_wrap (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_sampler_wrap>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_sampler_wrap, StringHash, gles_sampler_wrap__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_WRAP_T = "wrap_t";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__WRAP_T = "sampler_state__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__wrap_t()
{
bool failed;
gles_sampler_wrap parameter = Utils::toEnum<gles_sampler_wrap, StringHash, gles_sampler_wrap__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, gles_sampler_wrapMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MINFILTER = "minfilter";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__MINFILTER = "sampler_state__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_sampler_filter_common ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_sampler_filter_common (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_sampler_filter_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT, &toEnum_fx_sampler_filter_common>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_sampler_filter_common (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_sampler_filter_common*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>(text, textLength, dataFunction, fx_sampler_filter_commonMap, baseConversionFunc, &toEnum_fx_sampler_filter_common, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_sampler_filter_common);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_sampler_filter_common (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_sampler_filter_common*, size_t ),
    const std::pair<StringHash, fx_sampler_filter_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_sampler_filter_common (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_sampler_filter_common>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MAGFILTER = "magfilter";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__MAGFILTER = "sampler_state__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIPFILTER = "mipfilter";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__MIPFILTER = "sampler_state__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIPMAP_MAXLEVEL = "mipmap_maxlevel";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__MIPMAP_MAXLEVEL = "sampler_state__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIPMAP_BIAS = "mipmap_bias";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__MIPMAP_BIAS = "sampler_state__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler_state__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER_STATE__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER_STATE__EXTRA = "sampler_state__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler_state__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER_STATE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler_state__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_UNIT = "texture_unit";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__TEXTURE_UNIT = "newparam__texture_unit";

//---------------------------------------------------------------------
const texture_unit__AttributeData texture_unit__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__texture_unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_unit__AttributeData* attributeData = newData<texture_unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__TEXTURE_UNIT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__texture_unit()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__texture_unit( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_UNIT__SURFACE = "texture_unit__surface";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_unit__surface( const ParserChar* text, size_t textLength )
{
return mImpl->data__texture_unit__surface(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_unit__surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_UNIT__SAMPLER_STATE = "texture_unit__sampler_state";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_unit__sampler_state( const ParserChar* text, size_t textLength )
{
return mImpl->data__texture_unit__sampler_state(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_unit__sampler_state( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXCOORD = "texcoord";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_UNIT__TEXCOORD = "texture_unit__texcoord";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SEMANTIC = "semantic";

//---------------------------------------------------------------------
const texcoord__AttributeData texcoord__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texcoord( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texcoord( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcoord__AttributeData* attributeData = newData<texcoord__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXCOORD, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texcoord()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texcoord( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_UNIT__EXTRA = "texture_unit__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_unit__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_UNIT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_unit__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ENUM = "enum";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__ENUM = "newparam__enum";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__enum( const ParserChar* text, size_t textLength )
{
return mImpl->data__newparam__enum(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__enum()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE = "profile_GLES__technique";

//---------------------------------------------------------------------
const profile_GLES__technique__AttributeData profile_GLES__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__technique__AttributeData* attributeData = newData<profile_GLES__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__ASSET = "technique__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__ANNOTATE = "technique__annotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__IMAGE = "technique__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__NEWPARAM = "technique__newparam";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__newparam__AttributeData* attributeData = newData<technique__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM = "setparam";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__SETPARAM = "technique__setparam";

//---------------------------------------------------------------------
const technique__setparam__AttributeData technique__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__setparam__AttributeData* attributeData = newData<technique__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__SETPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__setparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__ANNOTATE = "setparam__annotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL = "setparam__bool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__bool(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__BOOL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL2 = "setparam__bool2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL3 = "setparam__bool3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL4 = "setparam__bool4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT = "setparam__int";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__int(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__INT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT2 = "setparam__int2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT3 = "setparam__int3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT4 = "setparam__int4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT = "setparam__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT2 = "setparam__float2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT3 = "setparam__float3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT4 = "setparam__float4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT1X1 = "setparam__float1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float1x1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__float1x1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__FLOAT1X1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT1X2 = "setparam__float1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT1X3 = "setparam__float1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT1X4 = "setparam__float1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT2X1 = "setparam__float2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT2X2 = "setparam__float2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT2X3 = "setparam__float2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT2X4 = "setparam__float2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT3X1 = "setparam__float3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT3X2 = "setparam__float3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT3X3 = "setparam__float3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT3X4 = "setparam__float3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT4X1 = "setparam__float4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT4X2 = "setparam__float4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT4X3 = "setparam__float4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT4X4 = "setparam__float4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__float4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SURFACE = "setparam__surface";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__surface__AttributeData* attributeData = newData<setparam__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(attributeValue, failed, fx_surface_type_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__SURFACE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__SURFACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__TEXTURE_PIPELINE = "setparam__texture_pipeline";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__texture_pipeline__AttributeData* attributeData = newData<setparam__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__TEXTURE_PIPELINE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__texture_pipeline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLER_STATE = "setparam__sampler_state";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__sampler_state( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__sampler_state__AttributeData* attributeData = newData<setparam__sampler_state__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__SAMPLER_STATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__sampler_state( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__TEXTURE_UNIT = "setparam__texture_unit";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__texture_unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_unit__AttributeData* attributeData = newData<texture_unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__TEXTURE_UNIT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__texture_unit()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__texture_unit( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__ENUM = "setparam__enum";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__enum( const ParserChar* text, size_t textLength )
{
return mImpl->data__setparam__enum(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__enum()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS = "pass";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__PASS = "technique__pass";

//---------------------------------------------------------------------
const pass__AttributeData pass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__pass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__pass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__AttributeData* attributeData = newData<pass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__pass()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__pass( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__ANNOTATE = "pass__annotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__pass__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__pass__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__pass__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__pass__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR_TARGET = "color_target";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__COLOR_TARGET = "pass__color_target";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__color_target( const ParserChar* text, size_t textLength )
{
return mImpl->data__color_target(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__color_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__color_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__color_target( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_TARGET = "depth_target";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_TARGET = "pass__depth_target";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_target( const ParserChar* text, size_t textLength )
{
return mImpl->data__depth_target(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_target( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_TARGET = "stencil_target";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_TARGET = "pass__stencil_target";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_target( const ParserChar* text, size_t textLength )
{
return mImpl->data__stencil_target(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_target( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR_CLEAR = "color_clear";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__COLOR_CLEAR = "pass__color_clear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__color_clear( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__color_clear);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__color_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__color_clear()
{
return doubleDataEnd( &ColladaParserAutoGen::data__color_clear );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__color_clear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_CLEAR = "depth_clear";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_CLEAR = "pass__depth_clear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_clear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_clear()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__depth_clear(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DEPTH_CLEAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_clear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_CLEAR = "stencil_clear";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_CLEAR = "pass__stencil_clear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_clear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_clear()
{
bool failed;
short parameter = GeneratedSaxParser::Utils::toShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__stencil_clear(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_STENCIL_CLEAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_clear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DRAW = "draw";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DRAW = "pass__draw";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__draw( const ParserChar* text, size_t textLength )
{
return mImpl->data__draw(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__draw( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__draw()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__draw( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA_FUNC = "alpha_func";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__ALPHA_FUNC = "pass__alpha_func";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__alpha_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__alpha_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FUNC = "func";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA_FUNC__FUNC = "alpha_func__func";

//---------------------------------------------------------------------
const alpha_func__func__AttributeData alpha_func__func__AttributeData::DEFAULT = {gl_func_type__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__alpha_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_func__func__AttributeData* attributeData = newData<alpha_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_func_type, StringHash, gl_func_type__COUNT>(attributeValue, failed, gl_func_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__FUNC, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA_FUNC__FUNC, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func__func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__alpha_func__func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_func_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_func_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_func_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_func_type, StringHash, gl_func_type__COUNT, &toEnum_gl_func_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_func_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_func_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_func_type, StringHash, gl_func_type__COUNT>(text, textLength, dataFunction, gl_func_typeMap, baseConversionFunc, &toEnum_gl_func_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_func_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_func_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_func_type*, size_t ),
    const std::pair<StringHash, gl_func_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_func_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_func_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_func_type, StringHash, gl_func_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VALUE = "value";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA_FUNC__VALUE = "alpha_func__value";

//---------------------------------------------------------------------
const alpha_func__value__AttributeData alpha_func__value__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__alpha_func__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_func__value__AttributeData* attributeData = newData<alpha_func__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__VALUE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA_FUNC__VALUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func__value()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__alpha_func__value( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLEND_FUNC = "blend_func";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__BLEND_FUNC = "pass__blend_func";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blend_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blend_func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blend_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SRC = "src";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLEND_FUNC__SRC = "blend_func__src";

//---------------------------------------------------------------------
const src__AttributeData src__AttributeData::DEFAULT = {gl_blend_type__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
src__AttributeData* attributeData = newData<src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_blend_type, StringHash, gl_blend_type__COUNT>(attributeValue, failed, gl_blend_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SRC, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__src()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__src( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_blend_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_blend_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_blend_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_blend_type, StringHash, gl_blend_type__COUNT, &toEnum_gl_blend_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_blend_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_blend_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_blend_type, StringHash, gl_blend_type__COUNT>(text, textLength, dataFunction, gl_blend_typeMap, baseConversionFunc, &toEnum_gl_blend_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_blend_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_blend_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_blend_type*, size_t ),
    const std::pair<StringHash, gl_blend_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_blend_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_blend_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_blend_type, StringHash, gl_blend_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEST = "dest";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLEND_FUNC__DEST = "blend_func__dest";

//---------------------------------------------------------------------
const dest__AttributeData dest__AttributeData::DEFAULT = {gl_blend_type__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__dest( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dest__AttributeData* attributeData = newData<dest__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_blend_type, StringHash, gl_blend_type__COUNT>(attributeValue, failed, gl_blend_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEST, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__dest()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__dest( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CLEAR_COLOR = "clear_color";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CLEAR_COLOR = "pass__clear_color";

//---------------------------------------------------------------------
const clear_color__AttributeData clear_color__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__clear_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__clear_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_color__AttributeData* attributeData = newData<clear_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_COLOR, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLEAR_COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__clear_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__clear_color( void* attributeData )
{
    clear_color__AttributeData* typedAttributeData = static_cast<clear_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CLEAR_STENCIL = "clear_stencil";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CLEAR_STENCIL = "pass__clear_stencil";

//---------------------------------------------------------------------
const clear_stencil__AttributeData clear_stencil__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__clear_stencil( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__clear_stencil( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_stencil__AttributeData* attributeData = newData<clear_stencil__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_STENCIL, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLEAR_STENCIL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__clear_stencil()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__clear_stencil( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CLEAR_DEPTH = "clear_depth";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CLEAR_DEPTH = "pass__clear_depth";

//---------------------------------------------------------------------
const clear_depth__AttributeData clear_depth__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__clear_depth( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__clear_depth( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_depth__AttributeData* attributeData = newData<clear_depth__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_DEPTH, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLEAR_DEPTH, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__clear_depth()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__clear_depth( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CLIP_PLANE = "clip_plane";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CLIP_PLANE = "pass__clip_plane";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_INDEX = "index";

//---------------------------------------------------------------------
const clip_plane__AttributeData clip_plane__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<bool>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__clip_plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__clip_plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clip_plane__AttributeData* attributeData = newData<clip_plane__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2BoolList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__clip_plane()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__clip_plane( void* attributeData )
{
    clip_plane__AttributeData* typedAttributeData = static_cast<clip_plane__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR_MASK = "color_mask";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__COLOR_MASK = "pass__color_mask";

//---------------------------------------------------------------------
const color_mask__AttributeData color_mask__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<bool>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__color_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_mask__AttributeData* attributeData = newData<color_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2BoolList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MASK, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__color_mask()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__color_mask( void* attributeData )
{
    color_mask__AttributeData* typedAttributeData = static_cast<color_mask__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CULL_FACE = "cull_face";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CULL_FACE = "pass__cull_face";

//---------------------------------------------------------------------
const cull_face__AttributeData cull_face__AttributeData::DEFAULT = {gl_face_type__BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cull_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
cull_face__AttributeData* attributeData = newData<cull_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_face_type, StringHash, gl_face_type__COUNT>(attributeValue, failed, gl_face_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cull_face()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cull_face( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_face_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_face_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_face_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_face_type, StringHash, gl_face_type__COUNT, &toEnum_gl_face_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_face_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_face_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_face_type, StringHash, gl_face_type__COUNT>(text, textLength, dataFunction, gl_face_typeMap, baseConversionFunc, &toEnum_gl_face_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_face_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_face_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_face_type*, size_t ),
    const std::pair<StringHash, gl_face_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_face_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_face_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_face_type, StringHash, gl_face_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_FUNC = "depth_func";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_FUNC = "pass__depth_func";

//---------------------------------------------------------------------
const depth_func__AttributeData depth_func__AttributeData::DEFAULT = {gl_func_type__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_func__AttributeData* attributeData = newData<depth_func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_func_type, StringHash, gl_func_type__COUNT>(attributeValue, failed, gl_func_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_FUNC, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_FUNC, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_MASK = "depth_mask";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_MASK = "pass__depth_mask";

//---------------------------------------------------------------------
const depth_mask__AttributeData depth_mask__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_mask__AttributeData* attributeData = newData<depth_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_MASK, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_mask()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_mask( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_RANGE = "depth_range";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_RANGE = "pass__depth_range";

//---------------------------------------------------------------------
const depth_range__AttributeData depth_range__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_range__AttributeData* attributeData = newData<depth_range__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_RANGE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_RANGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_range()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_range( void* attributeData )
{
    depth_range__AttributeData* typedAttributeData = static_cast<depth_range__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_COLOR = "fog_color";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_COLOR = "pass__fog_color";

//---------------------------------------------------------------------
const fog_color__AttributeData fog_color__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_color__AttributeData* attributeData = newData<fog_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_COLOR, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_color( void* attributeData )
{
    fog_color__AttributeData* typedAttributeData = static_cast<fog_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_DENSITY = "fog_density";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_DENSITY = "pass__fog_density";

//---------------------------------------------------------------------
const fog_density__AttributeData fog_density__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_density( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_density__AttributeData* attributeData = newData<fog_density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_DENSITY, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_DENSITY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_density()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_density( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_MODE = "fog_mode";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_MODE = "pass__fog_mode";

//---------------------------------------------------------------------
const fog_mode__AttributeData fog_mode__AttributeData::DEFAULT = {gl_fog_type__EXP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_mode__AttributeData* attributeData = newData<fog_mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_fog_type, StringHash, gl_fog_type__COUNT>(attributeValue, failed, gl_fog_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_MODE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_MODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_mode()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_mode( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_fog_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_fog_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_fog_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_fog_type, StringHash, gl_fog_type__COUNT, &toEnum_gl_fog_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_fog_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_fog_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_fog_type, StringHash, gl_fog_type__COUNT>(text, textLength, dataFunction, gl_fog_typeMap, baseConversionFunc, &toEnum_gl_fog_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_fog_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_fog_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_fog_type*, size_t ),
    const std::pair<StringHash, gl_fog_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_fog_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_fog_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_fog_type, StringHash, gl_fog_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_START = "fog_start";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_START = "pass__fog_start";

//---------------------------------------------------------------------
const fog_start__AttributeData fog_start__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_start( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_start__AttributeData* attributeData = newData<fog_start__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_START, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_START, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_start()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_start( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_END = "fog_end";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_END = "pass__fog_end";

//---------------------------------------------------------------------
const fog_end__AttributeData fog_end__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_end( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_end__AttributeData* attributeData = newData<fog_end__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_END, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_END, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_end()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_end( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FRONT_FACE = "front_face";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FRONT_FACE = "pass__front_face";

//---------------------------------------------------------------------
const front_face__AttributeData front_face__AttributeData::DEFAULT = {gl_front_face_type__CCW, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__front_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
front_face__AttributeData* attributeData = newData<front_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_front_face_type, StringHash, gl_front_face_type__COUNT>(attributeValue, failed, gl_front_face_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FRONT_FACE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT_FACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__front_face()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__front_face( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_front_face_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_front_face_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_front_face_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_front_face_type, StringHash, gl_front_face_type__COUNT, &toEnum_gl_front_face_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_front_face_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_front_face_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_front_face_type, StringHash, gl_front_face_type__COUNT>(text, textLength, dataFunction, gl_front_face_typeMap, baseConversionFunc, &toEnum_gl_front_face_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_front_face_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_front_face_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_front_face_type*, size_t ),
    const std::pair<StringHash, gl_front_face_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_front_face_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_front_face_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_front_face_type, StringHash, gl_front_face_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__TEXTURE_PIPELINE = "pass__texture_pipeline";

//---------------------------------------------------------------------
const pass__texture_pipeline__AttributeData pass__texture_pipeline__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__pass__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__pass__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__texture_pipeline__AttributeData* attributeData = newData<pass__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS__TEXTURE_PIPELINE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__pass__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__pass__texture_pipeline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE__VALUE = "texture_pipeline__value";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_pipeline__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline__value__AttributeData* attributeData = newData<texture_pipeline__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_PIPELINE__VALUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__value()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_pipeline__value( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VALUE__TEXCOMBINER = "value__texcombiner";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__value__texcombiner( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__value__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__value__texcombiner()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__value__texcombiner( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VALUE__TEXENV = "value__texenv";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__value__texenv( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__value__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texenv__AttributeData* attributeData = newData<texenv__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<gles_texenv_mode_enums, StringHash, gles_texenv_mode_enums__COUNT>(attributeValue, failed, gles_texenv_mode_enumsMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VALUE__TEXENV, HASH_ATTRIBUTE__OPERATOR, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE__TEXENV, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__value__texenv()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__value__texenv( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VALUE__EXTRA = "value__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__value__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__value__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__value__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__value__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LOGIC_OP = "logic_op";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LOGIC_OP = "pass__logic_op";

//---------------------------------------------------------------------
const logic_op__AttributeData logic_op__AttributeData::DEFAULT = {gl_logic_op_type__COPY, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__logic_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__logic_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
logic_op__AttributeData* attributeData = newData<logic_op__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_logic_op_type, StringHash, gl_logic_op_type__COUNT>(attributeValue, failed, gl_logic_op_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LOGIC_OP, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOGIC_OP, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__logic_op()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__logic_op( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_logic_op_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_logic_op_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_logic_op_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_logic_op_type, StringHash, gl_logic_op_type__COUNT, &toEnum_gl_logic_op_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_logic_op_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_logic_op_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_logic_op_type, StringHash, gl_logic_op_type__COUNT>(text, textLength, dataFunction, gl_logic_op_typeMap, baseConversionFunc, &toEnum_gl_logic_op_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_logic_op_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_logic_op_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_logic_op_type*, size_t ),
    const std::pair<StringHash, gl_logic_op_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_logic_op_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_logic_op_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_logic_op_type, StringHash, gl_logic_op_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_AMBIENT = "light_ambient";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_AMBIENT = "pass__light_ambient";

//---------------------------------------------------------------------
const light_ambient__AttributeData light_ambient__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_ambient__AttributeData* attributeData = newData<light_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_AMBIENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_ambient( void* attributeData )
{
    light_ambient__AttributeData* typedAttributeData = static_cast<light_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_DIFFUSE = "light_diffuse";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_DIFFUSE = "pass__light_diffuse";

//---------------------------------------------------------------------
const light_diffuse__AttributeData light_diffuse__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_diffuse__AttributeData* attributeData = newData<light_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_DIFFUSE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_diffuse( void* attributeData )
{
    light_diffuse__AttributeData* typedAttributeData = static_cast<light_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_SPECULAR = "light_specular";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_SPECULAR = "pass__light_specular";

//---------------------------------------------------------------------
const light_specular__AttributeData light_specular__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_specular__AttributeData* attributeData = newData<light_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPECULAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_specular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_specular( void* attributeData )
{
    light_specular__AttributeData* typedAttributeData = static_cast<light_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_POSITION = "light_position";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_POSITION = "pass__light_position";

//---------------------------------------------------------------------
const light_position__AttributeData light_position__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_position( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_position( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_position__AttributeData* attributeData = newData<light_position__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_POSITION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_position()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_position( void* attributeData )
{
    light_position__AttributeData* typedAttributeData = static_cast<light_position__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_CONSTANT_ATTENUATION = "light_constant_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_CONSTANT_ATTENUATION = "pass__light_constant_attenuation";

//---------------------------------------------------------------------
const light_constant_attenuation__AttributeData light_constant_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_constant_attenuation__AttributeData* attributeData = newData<light_constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_constant_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_constant_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_LINEAR_ATTENUTATION = "light_linear_attenutation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_LINEAR_ATTENUTATION = "pass__light_linear_attenutation";

//---------------------------------------------------------------------
const light_linear_attenutation__AttributeData light_linear_attenutation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_linear_attenutation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_linear_attenutation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_linear_attenutation__AttributeData* attributeData = newData<light_linear_attenutation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_linear_attenutation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_linear_attenutation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_QUADRATIC_ATTENUATION = "light_quadratic_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_QUADRATIC_ATTENUATION = "pass__light_quadratic_attenuation";

//---------------------------------------------------------------------
const light_quadratic_attenuation__AttributeData light_quadratic_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_quadratic_attenuation__AttributeData* attributeData = newData<light_quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_quadratic_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_quadratic_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_SPOT_CUTOFF = "light_spot_cutoff";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_SPOT_CUTOFF = "pass__light_spot_cutoff";

//---------------------------------------------------------------------
const light_spot_cutoff__AttributeData light_spot_cutoff__AttributeData::DEFAULT = {1.8E2, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_spot_cutoff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_cutoff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_cutoff__AttributeData* attributeData = newData<light_spot_cutoff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_CUTOFF, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_cutoff()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_spot_cutoff( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_SPOT_DIRECTION = "light_spot_direction";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_SPOT_DIRECTION = "pass__light_spot_direction";

//---------------------------------------------------------------------
const light_spot_direction__AttributeData light_spot_direction__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_spot_direction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_direction__AttributeData* attributeData = newData<light_spot_direction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_direction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_spot_direction( void* attributeData )
{
    light_spot_direction__AttributeData* typedAttributeData = static_cast<light_spot_direction__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_SPOT_EXPONENT = "light_spot_exponent";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_SPOT_EXPONENT = "pass__light_spot_exponent";

//---------------------------------------------------------------------
const light_spot_exponent__AttributeData light_spot_exponent__AttributeData::DEFAULT = {0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_spot_exponent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_exponent__AttributeData* attributeData = newData<light_spot_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_EXPONENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_exponent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_spot_exponent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_MODEL_AMBIENT = "light_model_ambient";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_MODEL_AMBIENT = "pass__light_model_ambient";

//---------------------------------------------------------------------
const light_model_ambient__AttributeData light_model_ambient__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_model_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_model_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_model_ambient__AttributeData* attributeData = newData<light_model_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_AMBIENT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_AMBIENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_model_ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_model_ambient( void* attributeData )
{
    light_model_ambient__AttributeData* typedAttributeData = static_cast<light_model_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINE_WIDTH = "line_width";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LINE_WIDTH = "pass__line_width";

//---------------------------------------------------------------------
const line_width__AttributeData line_width__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__line_width( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
line_width__AttributeData* attributeData = newData<line_width__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_WIDTH, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_WIDTH, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__line_width()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__line_width( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL_AMBIENT = "material_ambient";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MATERIAL_AMBIENT = "pass__material_ambient";

//---------------------------------------------------------------------
const material_ambient__AttributeData material_ambient__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_ambient__AttributeData* attributeData = newData<material_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_AMBIENT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_AMBIENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material_ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material_ambient( void* attributeData )
{
    material_ambient__AttributeData* typedAttributeData = static_cast<material_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL_DIFFUSE = "material_diffuse";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MATERIAL_DIFFUSE = "pass__material_diffuse";

//---------------------------------------------------------------------
const material_diffuse__AttributeData material_diffuse__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_diffuse__AttributeData* attributeData = newData<material_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_DIFFUSE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_DIFFUSE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material_diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material_diffuse( void* attributeData )
{
    material_diffuse__AttributeData* typedAttributeData = static_cast<material_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL_EMISSION = "material_emission";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MATERIAL_EMISSION = "pass__material_emission";

//---------------------------------------------------------------------
const material_emission__AttributeData material_emission__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material_emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material_emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_emission__AttributeData* attributeData = newData<material_emission__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_EMISSION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_EMISSION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material_emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material_emission( void* attributeData )
{
    material_emission__AttributeData* typedAttributeData = static_cast<material_emission__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL_SHININESS = "material_shininess";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MATERIAL_SHININESS = "pass__material_shininess";

//---------------------------------------------------------------------
const material_shininess__AttributeData material_shininess__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material_shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material_shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_shininess__AttributeData* attributeData = newData<material_shininess__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SHININESS, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SHININESS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material_shininess()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material_shininess( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL_SPECULAR = "material_specular";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MATERIAL_SPECULAR = "pass__material_specular";

//---------------------------------------------------------------------
const material_specular__AttributeData material_specular__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_specular__AttributeData* attributeData = newData<material_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SPECULAR, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SPECULAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material_specular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material_specular( void* attributeData )
{
    material_specular__AttributeData* typedAttributeData = static_cast<material_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MODEL_VIEW_MATRIX = "model_view_matrix";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MODEL_VIEW_MATRIX = "pass__model_view_matrix";

//---------------------------------------------------------------------
const model_view_matrix__AttributeData model_view_matrix__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__model_view_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__model_view_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
model_view_matrix__AttributeData* attributeData = newData<model_view_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MODEL_VIEW_MATRIX, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MODEL_VIEW_MATRIX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__model_view_matrix()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__model_view_matrix( void* attributeData )
{
    model_view_matrix__AttributeData* typedAttributeData = static_cast<model_view_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_DISTANCE_ATTENUATION = "point_distance_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_DISTANCE_ATTENUATION = "pass__point_distance_attenuation";

//---------------------------------------------------------------------
const point_distance_attenuation__AttributeData point_distance_attenuation__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_distance_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_distance_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_distance_attenuation__AttributeData* attributeData = newData<point_distance_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_distance_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_distance_attenuation( void* attributeData )
{
    point_distance_attenuation__AttributeData* typedAttributeData = static_cast<point_distance_attenuation__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_FADE_THRESHOLD_SIZE = "point_fade_threshold_size";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_FADE_THRESHOLD_SIZE = "pass__point_fade_threshold_size";

//---------------------------------------------------------------------
const point_fade_threshold_size__AttributeData point_fade_threshold_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_fade_threshold_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_fade_threshold_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_fade_threshold_size__AttributeData* attributeData = newData<point_fade_threshold_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_fade_threshold_size()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_fade_threshold_size( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_SIZE = "point_size";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_SIZE = "pass__point_size";

//---------------------------------------------------------------------
const point_size__AttributeData point_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size__AttributeData* attributeData = newData<point_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_size()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_size( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_SIZE_MIN = "point_size_min";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_SIZE_MIN = "pass__point_size_min";

//---------------------------------------------------------------------
const point_size_min__AttributeData point_size_min__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_size_min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_size_min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size_min__AttributeData* attributeData = newData<point_size_min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MIN, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MIN, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_size_min()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_size_min( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_SIZE_MAX = "point_size_max";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_SIZE_MAX = "pass__point_size_max";

//---------------------------------------------------------------------
const point_size_max__AttributeData point_size_max__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_size_max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_size_max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size_max__AttributeData* attributeData = newData<point_size_max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MAX, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MAX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_size_max()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_size_max( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGON_OFFSET = "polygon_offset";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POLYGON_OFFSET = "pass__polygon_offset";

//---------------------------------------------------------------------
const polygon_offset__AttributeData polygon_offset__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polygon_offset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygon_offset__AttributeData* attributeData = newData<polygon_offset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polygon_offset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polygon_offset( void* attributeData )
{
    polygon_offset__AttributeData* typedAttributeData = static_cast<polygon_offset__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROJECTION_MATRIX = "projection_matrix";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__PROJECTION_MATRIX = "pass__projection_matrix";

//---------------------------------------------------------------------
const projection_matrix__AttributeData projection_matrix__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<double>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__projection_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__projection_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
projection_matrix__AttributeData* attributeData = newData<projection_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2DoubleList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROJECTION_MATRIX, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROJECTION_MATRIX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__projection_matrix()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__projection_matrix( void* attributeData )
{
    projection_matrix__AttributeData* typedAttributeData = static_cast<projection_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCISSOR = "scissor";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SCISSOR = "pass__scissor";

//---------------------------------------------------------------------
const scissor__AttributeData scissor__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<long>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__scissor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scissor__AttributeData* attributeData = newData<scissor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

bool failed = characterData2LongList(attributeValue, attributeData->value);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__scissor()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__scissor( void* attributeData )
{
    scissor__AttributeData* typedAttributeData = static_cast<scissor__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHADE_MODEL = "shade_model";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SHADE_MODEL = "pass__shade_model";

//---------------------------------------------------------------------
const shade_model__AttributeData shade_model__AttributeData::DEFAULT = {gl_shade_model_type__SMOOTH, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shade_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shade_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shade_model__AttributeData* attributeData = newData<shade_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_shade_model_type, StringHash, gl_shade_model_type__COUNT>(attributeValue, failed, gl_shade_model_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHADE_MODEL, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADE_MODEL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shade_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shade_model( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gl_shade_model_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_shade_model_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gl_shade_model_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gl_shade_model_type, StringHash, gl_shade_model_type__COUNT, &toEnum_gl_shade_model_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gl_shade_model_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_shade_model_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gl_shade_model_type, StringHash, gl_shade_model_type__COUNT>(text, textLength, dataFunction, gl_shade_model_typeMap, baseConversionFunc, &toEnum_gl_shade_model_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gl_shade_model_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gl_shade_model_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gl_shade_model_type*, size_t ),
    const std::pair<StringHash, gl_shade_model_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gl_shade_model_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gl_shade_model_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gl_shade_model_type, StringHash, gl_shade_model_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_FUNC = "stencil_func";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_FUNC = "pass__stencil_func";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_FUNC__FUNC = "stencil_func__func";

//---------------------------------------------------------------------
const stencil_func__func__AttributeData stencil_func__func__AttributeData::DEFAULT = {gl_func_type__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__func__AttributeData* attributeData = newData<stencil_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gl_func_type, StringHash, gl_func_type__COUNT>(attributeValue, failed, gl_func_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__FUNC, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_FUNC__FUNC, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__func()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_func__func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REF = "ref";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_FUNC__REF = "stencil_func__ref";

//---------------------------------------------------------------------
const stencil_func__ref__AttributeData stencil_func__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_func__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__ref__AttributeData* attributeData = newData<stencil_func__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__REF, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_FUNC__REF, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__ref()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_func__ref( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MASK = "mask";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_FUNC__MASK = "stencil_func__mask";

//---------------------------------------------------------------------
const stencil_func__mask__AttributeData stencil_func__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_func__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__mask__AttributeData* attributeData = newData<stencil_func__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_FUNC__MASK, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__mask()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_func__mask( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_MASK = "stencil_mask";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_MASK = "pass__stencil_mask";

//---------------------------------------------------------------------
const stencil_mask__AttributeData stencil_mask__AttributeData::DEFAULT = {4294967295, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_mask__AttributeData* attributeData = newData<stencil_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_MASK, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_mask()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_mask( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_OP = "stencil_op";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_OP = "pass__stencil_op";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_op( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FAIL = "fail";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_OP__FAIL = "stencil_op__fail";

//---------------------------------------------------------------------
const stencil_op__fail__AttributeData stencil_op__fail__AttributeData::DEFAULT = {gles_stencil_op_type__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_op__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__fail__AttributeData* attributeData = newData<stencil_op__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT>(attributeValue, failed, gles_stencil_op_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__FAIL, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_OP__FAIL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__fail()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_op__fail( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
gles_stencil_op_type ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_stencil_op_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, gles_stencil_op_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT, &toEnum_gles_stencil_op_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_gles_stencil_op_type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_stencil_op_type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT>(text, textLength, dataFunction, gles_stencil_op_typeMap, baseConversionFunc, &toEnum_gles_stencil_op_type, &ColladaParserAutoGenPrivate::toEnumDataPrefix_gles_stencil_op_type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_gles_stencil_op_type (
    bool ( ColladaParserAutoGen::*dataFunction )(const gles_stencil_op_type*, size_t ),
    const std::pair<StringHash, gles_stencil_op_type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    gles_stencil_op_type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, gles_stencil_op_type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ZFAIL = "zfail";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_OP__ZFAIL = "stencil_op__zfail";

//---------------------------------------------------------------------
const stencil_op__zfail__AttributeData stencil_op__zfail__AttributeData::DEFAULT = {gles_stencil_op_type__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_op__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__zfail__AttributeData* attributeData = newData<stencil_op__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT>(attributeValue, failed, gles_stencil_op_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZFAIL, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_OP__ZFAIL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__zfail()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_op__zfail( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ZPASS = "zpass";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_OP__ZPASS = "stencil_op__zpass";

//---------------------------------------------------------------------
const stencil_op__zpass__AttributeData stencil_op__zpass__AttributeData::DEFAULT = {gles_stencil_op_type__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_op__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__zpass__AttributeData* attributeData = newData<stencil_op__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<gles_stencil_op_type, StringHash, gles_stencil_op_type__COUNT>(attributeValue, failed, gles_stencil_op_typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZPASS, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_OP__ZPASS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__zpass()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_op__zpass( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ALPHA_TEST_ENABLE = "alpha_test_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__ALPHA_TEST_ENABLE = "pass__alpha_test_enable";

//---------------------------------------------------------------------
const alpha_test_enable__AttributeData alpha_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__alpha_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__alpha_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_test_enable__AttributeData* attributeData = newData<alpha_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_TEST_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA_TEST_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__alpha_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__alpha_test_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLEND_ENABLE = "blend_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__BLEND_ENABLE = "pass__blend_enable";

//---------------------------------------------------------------------
const blend_enable__AttributeData blend_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blend_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
blend_enable__AttributeData* attributeData = newData<blend_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLEND_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blend_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blend_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CLIP_PLANE_ENABLE = "clip_plane_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CLIP_PLANE_ENABLE = "pass__clip_plane_enable";

//---------------------------------------------------------------------
const clip_plane_enable__AttributeData clip_plane_enable__AttributeData::DEFAULT = {false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__clip_plane_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__clip_plane_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clip_plane_enable__AttributeData* attributeData = newData<clip_plane_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__clip_plane_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__clip_plane_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR_LOGIC_OP_ENABLE = "color_logic_op_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__COLOR_LOGIC_OP_ENABLE = "pass__color_logic_op_enable";

//---------------------------------------------------------------------
const color_logic_op_enable__AttributeData color_logic_op_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__color_logic_op_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__color_logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_logic_op_enable__AttributeData* attributeData = newData<color_logic_op_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__color_logic_op_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__color_logic_op_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR_MATERIAL_ENABLE = "color_material_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__COLOR_MATERIAL_ENABLE = "pass__color_material_enable";

//---------------------------------------------------------------------
const color_material_enable__AttributeData color_material_enable__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__color_material_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__color_material_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_material_enable__AttributeData* attributeData = newData<color_material_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MATERIAL_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MATERIAL_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__color_material_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__color_material_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CULL_FACE_ENABLE = "cull_face_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__CULL_FACE_ENABLE = "pass__cull_face_enable";

//---------------------------------------------------------------------
const cull_face_enable__AttributeData cull_face_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cull_face_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
cull_face_enable__AttributeData* attributeData = newData<cull_face_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cull_face_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cull_face_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DEPTH_TEST_ENABLE = "depth_test_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DEPTH_TEST_ENABLE = "pass__depth_test_enable";

//---------------------------------------------------------------------
const depth_test_enable__AttributeData depth_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__depth_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_test_enable__AttributeData* attributeData = newData<depth_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_TEST_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_TEST_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__depth_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__depth_test_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DITHER_ENABLE = "dither_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__DITHER_ENABLE = "pass__dither_enable";

//---------------------------------------------------------------------
const dither_enable__AttributeData dither_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__dither_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dither_enable__AttributeData* attributeData = newData<dither_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DITHER_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DITHER_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__dither_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__dither_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FOG_ENABLE = "fog_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__FOG_ENABLE = "pass__fog_enable";

//---------------------------------------------------------------------
const fog_enable__AttributeData fog_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fog_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fog_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_enable__AttributeData* attributeData = newData<fog_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fog_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fog_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE_PIPELINE_ENABLE = "texture_pipeline_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__TEXTURE_PIPELINE_ENABLE = "pass__texture_pipeline_enable";

//---------------------------------------------------------------------
const texture_pipeline_enable__AttributeData texture_pipeline_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture_pipeline_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline_enable__AttributeData* attributeData = newData<texture_pipeline_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_PIPELINE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture_pipeline_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_ENABLE = "light_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_ENABLE = "pass__light_enable";

//---------------------------------------------------------------------
const light_enable__AttributeData light_enable__AttributeData::DEFAULT = {false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_enable__AttributeData* attributeData = newData<light_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHTING_ENABLE = "lighting_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHTING_ENABLE = "pass__lighting_enable";

//---------------------------------------------------------------------
const lighting_enable__AttributeData lighting_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lighting_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lighting_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lighting_enable__AttributeData* attributeData = newData<lighting_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHTING_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHTING_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lighting_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lighting_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE = "light_model_two_side_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LIGHT_MODEL_TWO_SIDE_ENABLE = "pass__light_model_two_side_enable";

//---------------------------------------------------------------------
const light_model_two_side_enable__AttributeData light_model_two_side_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light_model_two_side_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light_model_two_side_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_model_two_side_enable__AttributeData* attributeData = newData<light_model_two_side_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light_model_two_side_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light_model_two_side_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINE_SMOOTH_ENABLE = "line_smooth_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__LINE_SMOOTH_ENABLE = "pass__line_smooth_enable";

//---------------------------------------------------------------------
const line_smooth_enable__AttributeData line_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__line_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__line_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
line_smooth_enable__AttributeData* attributeData = newData<line_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_SMOOTH_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_SMOOTH_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__line_smooth_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__line_smooth_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MULTISAMPLE_ENABLE = "multisample_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__MULTISAMPLE_ENABLE = "pass__multisample_enable";

//---------------------------------------------------------------------
const multisample_enable__AttributeData multisample_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__multisample_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__multisample_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
multisample_enable__AttributeData* attributeData = newData<multisample_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MULTISAMPLE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MULTISAMPLE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__multisample_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__multisample_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NORMALIZE_ENABLE = "normalize_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__NORMALIZE_ENABLE = "pass__normalize_enable";

//---------------------------------------------------------------------
const normalize_enable__AttributeData normalize_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__normalize_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__normalize_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
normalize_enable__AttributeData* attributeData = newData<normalize_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NORMALIZE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NORMALIZE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__normalize_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__normalize_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT_SMOOTH_ENABLE = "point_smooth_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POINT_SMOOTH_ENABLE = "pass__point_smooth_enable";

//---------------------------------------------------------------------
const point_smooth_enable__AttributeData point_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_smooth_enable__AttributeData* attributeData = newData<point_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SMOOTH_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SMOOTH_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point_smooth_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point_smooth_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGON_OFFSET_FILL_ENABLE = "polygon_offset_fill_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__POLYGON_OFFSET_FILL_ENABLE = "pass__polygon_offset_fill_enable";

//---------------------------------------------------------------------
const polygon_offset_fill_enable__AttributeData polygon_offset_fill_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygon_offset_fill_enable__AttributeData* attributeData = newData<polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polygon_offset_fill_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polygon_offset_fill_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RESCALE_NORMAL_ENABLE = "rescale_normal_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__RESCALE_NORMAL_ENABLE = "pass__rescale_normal_enable";

//---------------------------------------------------------------------
const rescale_normal_enable__AttributeData rescale_normal_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rescale_normal_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rescale_normal_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rescale_normal_enable__AttributeData* attributeData = newData<rescale_normal_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RESCALE_NORMAL_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RESCALE_NORMAL_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rescale_normal_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rescale_normal_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "sample_alpha_to_coverage_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "pass__sample_alpha_to_coverage_enable";

//---------------------------------------------------------------------
const sample_alpha_to_coverage_enable__AttributeData sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sample_alpha_to_coverage_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sample_alpha_to_coverage_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE = "sample_alpha_to_one_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SAMPLE_ALPHA_TO_ONE_ENABLE = "pass__sample_alpha_to_one_enable";

//---------------------------------------------------------------------
const sample_alpha_to_one_enable__AttributeData sample_alpha_to_one_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sample_alpha_to_one_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sample_alpha_to_one_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_alpha_to_one_enable__AttributeData* attributeData = newData<sample_alpha_to_one_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sample_alpha_to_one_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sample_alpha_to_one_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLE_COVERAGE_ENABLE = "sample_coverage_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SAMPLE_COVERAGE_ENABLE = "pass__sample_coverage_enable";

//---------------------------------------------------------------------
const sample_coverage_enable__AttributeData sample_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sample_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_coverage_enable__AttributeData* attributeData = newData<sample_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sample_coverage_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sample_coverage_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCISSOR_TEST_ENABLE = "scissor_test_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__SCISSOR_TEST_ENABLE = "pass__scissor_test_enable";

//---------------------------------------------------------------------
const scissor_test_enable__AttributeData scissor_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__scissor_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scissor_test_enable__AttributeData* attributeData = newData<scissor_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR_TEST_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR_TEST_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__scissor_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__scissor_test_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STENCIL_TEST_ENABLE = "stencil_test_enable";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__STENCIL_TEST_ENABLE = "pass__stencil_test_enable";

//---------------------------------------------------------------------
const stencil_test_enable__AttributeData stencil_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__stencil_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_test_enable__AttributeData* attributeData = newData<stencil_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_TEST_ENABLE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_TEST_ENABLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__stencil_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__stencil_test_enable( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PASS__EXTRA = "pass__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__pass__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__pass__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__pass__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__pass__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__EXTRA = "technique__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLES__EXTRA = "profile_GLES__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLES__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLES__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA = "COLLADA";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_VERSION = "version";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_BASE = "base";

//---------------------------------------------------------------------
const COLLADA__AttributeData COLLADA__AttributeData::DEFAULT = {VersionType__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__COLLADA( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
COLLADA__AttributeData* attributeData = newData<COLLADA__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VERSION:
    {
bool failed;
attributeData->version = Utils::toEnum<VersionType, StringHash, VersionType__COUNT>(attributeValue, failed, VersionTypeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLLADA, HASH_ATTRIBUTE_VERSION, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_BASE:
    {

attributeData->base = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLLADA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__COLLADA( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
VersionType ColladaParserAutoGenPrivate::toEnumDataPrefix_VersionType (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, VersionType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<VersionType, StringHash, VersionType__COUNT, &toEnum_VersionType>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_VersionType (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const VersionType*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<VersionType, StringHash, VersionType__COUNT>(text, textLength, dataFunction, VersionTypeMap, baseConversionFunc, &toEnum_VersionType, &ColladaParserAutoGenPrivate::toEnumDataPrefix_VersionType);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_VersionType (
    bool ( ColladaParserAutoGen::*dataFunction )(const VersionType*, size_t ),
    const std::pair<StringHash, VersionType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    VersionType (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, VersionType>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<VersionType, StringHash, VersionType__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__ASSET = "COLLADA__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__COLLADA__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__COLLADA__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATIONS = "library_animations";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_ANIMATIONS = "COLLADA__library_animations";

//---------------------------------------------------------------------
const library_animations__AttributeData library_animations__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animations( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animations( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animations__AttributeData* attributeData = newData<library_animations__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATIONS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animations()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animations( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__ASSET = "library_animations__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animations__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animations__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animations__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animations__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION = "animation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__ANIMATION = "library_animations__animation";

//---------------------------------------------------------------------
const animation__AttributeData animation__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animations__animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animations__animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__AttributeData* attributeData = newData<animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATIONS__ANIMATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animations__animation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animations__animation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__ASSET = "animation__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE = "source";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__SOURCE = "animation__source";

//---------------------------------------------------------------------
const animation__source__AttributeData animation__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__source__AttributeData* attributeData = newData<animation__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__ASSET = "source__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__source__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__source__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__source__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__source__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IDREF_ARRAY = "IDREF_array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__IDREF_ARRAY = "source__IDREF_array";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_COUNT = "count";

//---------------------------------------------------------------------
const IDREF_array__AttributeData IDREF_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__IDREF_array( const ParserChar* text, size_t textLength )
{
return mImpl->data__IDREF_array(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__IDREF_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
IDREF_array__AttributeData* attributeData = newData<IDREF_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IDREF_ARRAY, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IDREF_ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__IDREF_array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__IDREF_array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NAME_ARRAY = "Name_array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__NAME_ARRAY = "source__Name_array";

//---------------------------------------------------------------------
const Name_array__AttributeData Name_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__Name_array( const ParserChar* text, size_t textLength )
{
return mImpl->data__Name_array(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__Name_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
Name_array__AttributeData* attributeData = newData<Name_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NAME_ARRAY, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NAME_ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__Name_array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__Name_array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL_ARRAY = "bool_array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__BOOL_ARRAY = "source__bool_array";

//---------------------------------------------------------------------
const bool_array__AttributeData bool_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bool_array( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__bool_array);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bool_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bool_array__AttributeData* attributeData = newData<bool_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BOOL_ARRAY, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BOOL_ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bool_array()
{
return boolDataEnd( &ColladaParserAutoGen::data__bool_array );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bool_array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT_ARRAY = "float_array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__FLOAT_ARRAY = "source__float_array";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_DIGITS = "digits";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_MAGNITUDE = "magnitude";

//---------------------------------------------------------------------
const float_array__AttributeData float_array__AttributeData::DEFAULT = {0, 0, 0, 6, 38};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__float_array( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__float_array);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__float_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
float_array__AttributeData* attributeData = newData<float_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DIGITS:
    {
bool failed;
attributeData->digits = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_DIGITS, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MAGNITUDE:
    {
bool failed;
attributeData->magnitude = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_MAGNITUDE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FLOAT_ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__float_array()
{
return doubleDataEnd( &ColladaParserAutoGen::data__float_array );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__float_array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT_ARRAY = "int_array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__INT_ARRAY = "source__int_array";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_MININCLUSIVE = "minInclusive";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_MAXINCLUSIVE = "maxInclusive";

//---------------------------------------------------------------------
const int_array__AttributeData int_array__AttributeData::DEFAULT = {0, 0, 0, -2147483648, 2147483647};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__int_array( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__int_array);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__int_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
int_array__AttributeData* attributeData = newData<int_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MININCLUSIVE:
    {
bool failed;
attributeData->minInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MININCLUSIVE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MAXINCLUSIVE:
    {
bool failed;
attributeData->maxInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MAXINCLUSIVE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INT_ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__int_array()
{
return longDataEnd( &ColladaParserAutoGen::data__int_array );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__int_array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON = "technique_common";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__TECHNIQUE_COMMON = "source__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__source__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__source__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__source__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__source__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ACCESSOR = "accessor";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__ACCESSOR = "technique_common__accessor";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_OFFSET = "offset";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_STRIDE = "stride";

//---------------------------------------------------------------------
const accessor__AttributeData accessor__AttributeData::DEFAULT = {0, 0, 0, 1};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__accessor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__accessor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
accessor__AttributeData* attributeData = newData<accessor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_STRIDE:
    {
bool failed;
attributeData->stride = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR, HASH_ATTRIBUTE_STRIDE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ACCESSOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__accessor()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__accessor( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PARAM = "param";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ACCESSOR__PARAM = "accessor__param";

//---------------------------------------------------------------------
const accessor__param__AttributeData accessor__param__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__accessor__param( const ParserChar* text, size_t textLength )
{
return mImpl->data__accessor__param(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__accessor__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
accessor__param__AttributeData* attributeData = newData<accessor__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ACCESSOR__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__accessor__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__accessor__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SOURCE__TECHNIQUE = "source__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__source__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__source__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
source__technique__AttributeData* attributeData = newData<source__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SOURCE__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__source__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__source__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER = "sampler";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__SAMPLER = "animation__sampler";

//---------------------------------------------------------------------
const sampler__AttributeData sampler__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler__AttributeData* attributeData = newData<sampler__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INPUT = "input";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER__INPUT = "sampler__input";

//---------------------------------------------------------------------
const sampler__input__AttributeData sampler__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler__input__AttributeData* attributeData = newData<sampler__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CHANNEL = "channel";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__CHANNEL = "animation__channel";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_TARGET = "target";

//---------------------------------------------------------------------
const channel__AttributeData channel__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__channel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__channel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
channel__AttributeData* attributeData = newData<channel__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CHANNEL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__channel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__channel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__ANIMATION = "animation__animation";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation__animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation__animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__AttributeData* attributeData = newData<animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION__ANIMATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation__animation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation__animation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION__EXTRA = "animation__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__EXTRA = "library_animations__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animations__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animations__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATIONS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animations__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animations__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS = "library_animation_clips";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_ANIMATION_CLIPS = "COLLADA__library_animation_clips";

//---------------------------------------------------------------------
const library_animation_clips__AttributeData library_animation_clips__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animation_clips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animation_clips__AttributeData* attributeData = newData<library_animation_clips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animation_clips( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__ASSET = "library_animation_clips__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animation_clips__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animation_clips__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION_CLIP = "animation_clip";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__ANIMATION_CLIP = "library_animation_clips__animation_clip";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_START = "start";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_END = "end";

//---------------------------------------------------------------------
const animation_clip__AttributeData animation_clip__AttributeData::DEFAULT = {0, 0, 0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation_clip( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation_clip__AttributeData* attributeData = newData<animation_clip__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_START:
    {
bool failed;
attributeData->start = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_START, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_END:
    {
bool failed;
attributeData->end = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_END, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION_CLIP, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation_clip( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION_CLIP__ASSET = "animation_clip__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation_clip__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation_clip__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_ANIMATION = "instance_animation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION_CLIP__INSTANCE_ANIMATION = "animation_clip__instance_animation";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_URL = "url";

//---------------------------------------------------------------------
const instance_animation__AttributeData instance_animation__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_animation__AttributeData* attributeData = newData<instance_animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_ANIMATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_animation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_animation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_ANIMATION__EXTRA = "instance_animation__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_animation__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_ANIMATION__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_animation__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_animation__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANIMATION_CLIP__EXTRA = "animation_clip__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__animation_clip__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION_CLIP__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__animation_clip__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__EXTRA = "library_animation_clips__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_animation_clips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_animation_clips__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CAMERAS = "library_cameras";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_CAMERAS = "COLLADA__library_cameras";

//---------------------------------------------------------------------
const library_cameras__AttributeData library_cameras__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_cameras( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_cameras__AttributeData* attributeData = newData<library_cameras__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CAMERAS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_cameras( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CAMERAS__ASSET = "library_cameras__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_cameras__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_cameras__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAMERA = "camera";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CAMERAS__CAMERA = "library_cameras__camera";

//---------------------------------------------------------------------
const camera__AttributeData camera__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
camera__AttributeData* attributeData = newData<camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CAMERA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__camera()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__camera( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAMERA__ASSET = "camera__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__camera__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__camera__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__camera__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__camera__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_OPTICS = "optics";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAMERA__OPTICS = "camera__optics";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__optics( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__optics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__optics()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__optics( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_OPTICS__TECHNIQUE_COMMON = "optics__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__optics__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__optics__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__optics__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__optics__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC = "orthographic";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__ORTHOGRAPHIC = "technique_common__orthographic";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__orthographic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__orthographic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__orthographic()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__orthographic( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_XMAG = "xmag";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC__XMAG = "orthographic__xmag";

//---------------------------------------------------------------------
const xmag__AttributeData xmag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__xmag( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__xmag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
xmag__AttributeData* attributeData = newData<xmag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_XMAG, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__xmag()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__xmag(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_XMAG, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__xmag( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_YMAG = "ymag";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC__YMAG = "orthographic__ymag";

//---------------------------------------------------------------------
const ymag__AttributeData ymag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ymag( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ymag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ymag__AttributeData* attributeData = newData<ymag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_YMAG, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ymag()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__ymag(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_YMAG, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ymag( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ASPECT_RATIO = "aspect_ratio";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO = "orthographic__aspect_ratio";

//---------------------------------------------------------------------
const aspect_ratio__AttributeData aspect_ratio__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__orthographic__aspect_ratio( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
aspect_ratio__AttributeData* attributeData = newData<aspect_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__aspect_ratio()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__orthographic__aspect_ratio(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__orthographic__aspect_ratio( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ZNEAR = "znear";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC__ZNEAR = "orthographic__znear";

//---------------------------------------------------------------------
const znear__AttributeData znear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__orthographic__znear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
znear__AttributeData* attributeData = newData<znear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ORTHOGRAPHIC__ZNEAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__znear()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__orthographic__znear(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ORTHOGRAPHIC__ZNEAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__orthographic__znear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ZFAR = "zfar";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ORTHOGRAPHIC__ZFAR = "orthographic__zfar";

//---------------------------------------------------------------------
const zfar__AttributeData zfar__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__orthographic__zfar( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
zfar__AttributeData* attributeData = newData<zfar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ORTHOGRAPHIC__ZFAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__zfar()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__orthographic__zfar(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ORTHOGRAPHIC__ZFAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__orthographic__zfar( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE = "perspective";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__PERSPECTIVE = "technique_common__perspective";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__perspective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__perspective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__perspective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__perspective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_XFOV = "xfov";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE__XFOV = "perspective__xfov";

//---------------------------------------------------------------------
const xfov__AttributeData xfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__xfov( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__xfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
xfov__AttributeData* attributeData = newData<xfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_XFOV, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__xfov()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__xfov(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_XFOV, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__xfov( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_YFOV = "yfov";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE__YFOV = "perspective__yfov";

//---------------------------------------------------------------------
const yfov__AttributeData yfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__yfov( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__yfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
yfov__AttributeData* attributeData = newData<yfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_YFOV, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__yfov()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__yfov(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_YFOV, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__yfov( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE__ASPECT_RATIO = "perspective__aspect_ratio";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__perspective__aspect_ratio( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__perspective__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
aspect_ratio__AttributeData* attributeData = newData<aspect_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PERSPECTIVE__ASPECT_RATIO, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__perspective__aspect_ratio()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__perspective__aspect_ratio(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_PERSPECTIVE__ASPECT_RATIO, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__perspective__aspect_ratio( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE__ZNEAR = "perspective__znear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__perspective__znear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__perspective__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
znear__AttributeData* attributeData = newData<znear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PERSPECTIVE__ZNEAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__perspective__znear()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__perspective__znear(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_PERSPECTIVE__ZNEAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__perspective__znear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PERSPECTIVE__ZFAR = "perspective__zfar";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__perspective__zfar( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__perspective__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
zfar__AttributeData* attributeData = newData<zfar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PERSPECTIVE__ZFAR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__perspective__zfar()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__perspective__zfar(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_PERSPECTIVE__ZFAR, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__perspective__zfar( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_OPTICS__TECHNIQUE = "optics__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__optics__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__optics__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
optics__technique__AttributeData* attributeData = newData<optics__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_OPTICS__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__optics__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__optics__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_OPTICS__EXTRA = "optics__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__optics__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__optics__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_OPTICS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__optics__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__optics__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGER = "imager";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAMERA__IMAGER = "camera__imager";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__imager( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__imager( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__imager()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__imager( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGER__TECHNIQUE = "imager__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__imager__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__imager__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
imager__technique__AttributeData* attributeData = newData<imager__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IMAGER__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__imager__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__imager__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_IMAGER__EXTRA = "imager__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__imager__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__imager__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IMAGER__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__imager__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__imager__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAMERA__EXTRA = "camera__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__camera__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CAMERA__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__camera__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__camera__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CAMERAS__EXTRA = "library_cameras__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_cameras__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CAMERAS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_cameras__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CONTROLLERS = "library_controllers";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_CONTROLLERS = "COLLADA__library_controllers";

//---------------------------------------------------------------------
const library_controllers__AttributeData library_controllers__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_controllers( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_controllers__AttributeData* attributeData = newData<library_controllers__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CONTROLLERS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_controllers( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__ASSET = "library_controllers__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_controllers__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_controllers__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROLLER = "controller";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__CONTROLLER = "library_controllers__controller";

//---------------------------------------------------------------------
const controller__AttributeData controller__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
controller__AttributeData* attributeData = newData<controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONTROLLER, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__controller()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__controller( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROLLER__ASSET = "controller__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__controller__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__controller__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__controller__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__controller__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN = "skin";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROLLER__SKIN = "controller__skin";

//---------------------------------------------------------------------
const skin__AttributeData skin__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__skin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__skin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skin__AttributeData* attributeData = newData<skin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKIN, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__skin()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__skin( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_SHAPE_MATRIX = "bind_shape_matrix";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN__BIND_SHAPE_MATRIX = "skin__bind_shape_matrix";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_shape_matrix( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__bind_shape_matrix);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_shape_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_shape_matrix()
{
return doubleDataEnd( &ColladaParserAutoGen::data__bind_shape_matrix );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_shape_matrix( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN__SOURCE = "skin__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__skin__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__skin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skin__source__AttributeData* attributeData = newData<skin__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKIN__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__skin__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__skin__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_JOINTS = "joints";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN__JOINTS = "skin__joints";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__joints( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__joints( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__joints()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__joints( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_JOINTS__INPUT = "joints__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__joints__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__joints__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
joints__input__AttributeData* attributeData = newData<joints__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_JOINTS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__joints__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__joints__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_JOINTS__EXTRA = "joints__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__joints__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__joints__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_JOINTS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__joints__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__joints__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTEX_WEIGHTS = "vertex_weights";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN__VERTEX_WEIGHTS = "skin__vertex_weights";

//---------------------------------------------------------------------
const vertex_weights__AttributeData vertex_weights__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertex_weights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertex_weights__AttributeData* attributeData = newData<vertex_weights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTEX_WEIGHTS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertex_weights( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTEX_WEIGHTS__INPUT = "vertex_weights__input";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SET = "set";

//---------------------------------------------------------------------
const vertex_weights__input__AttributeData vertex_weights__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertex_weights__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertex_weights__input__AttributeData* attributeData = newData<vertex_weights__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTEX_WEIGHTS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertex_weights__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VCOUNT = "vcount";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTEX_WEIGHTS__VCOUNT = "vertex_weights__vcount";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertex_weights__vcount( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__vertex_weights__vcount);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__vcount()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__vertex_weights__vcount );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertex_weights__vcount( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_V = "v";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTEX_WEIGHTS__V = "vertex_weights__v";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__v( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__v);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__v( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__v()
{
return longDataEnd( &ColladaParserAutoGen::data__v );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__v( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTEX_WEIGHTS__EXTRA = "vertex_weights__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertex_weights__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTEX_WEIGHTS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertex_weights__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKIN__EXTRA = "skin__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__skin__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__skin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKIN__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__skin__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__skin__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MORPH = "morph";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROLLER__MORPH = "controller__morph";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_METHOD = "method";

//---------------------------------------------------------------------
const morph__AttributeData morph__AttributeData::DEFAULT = {MorphMethodType__NORMALIZED, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__morph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__morph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
morph__AttributeData* attributeData = newData<morph__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METHOD:
    {
bool failed;
attributeData->method = Utils::toEnum<MorphMethodType, StringHash, MorphMethodType__COUNT>(attributeValue, failed, MorphMethodTypeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH, HASH_ATTRIBUTE_METHOD, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MORPH, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__morph()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__morph( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
MorphMethodType ColladaParserAutoGenPrivate::toEnumDataPrefix_MorphMethodType (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, MorphMethodType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<MorphMethodType, StringHash, MorphMethodType__COUNT, &toEnum_MorphMethodType>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_MorphMethodType (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const MorphMethodType*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<MorphMethodType, StringHash, MorphMethodType__COUNT>(text, textLength, dataFunction, MorphMethodTypeMap, baseConversionFunc, &toEnum_MorphMethodType, &ColladaParserAutoGenPrivate::toEnumDataPrefix_MorphMethodType);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_MorphMethodType (
    bool ( ColladaParserAutoGen::*dataFunction )(const MorphMethodType*, size_t ),
    const std::pair<StringHash, MorphMethodType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    MorphMethodType (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, MorphMethodType>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<MorphMethodType, StringHash, MorphMethodType__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MORPH__SOURCE = "morph__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__morph__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__morph__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
morph__source__AttributeData* attributeData = newData<morph__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MORPH__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__morph__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__morph__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TARGETS = "targets";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MORPH__TARGETS = "morph__targets";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__targets( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__targets( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__targets()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__targets( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TARGETS__INPUT = "targets__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__targets__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__targets__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
targets__input__AttributeData* attributeData = newData<targets__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TARGETS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__targets__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__targets__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TARGETS__EXTRA = "targets__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__targets__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__targets__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TARGETS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__targets__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__targets__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MORPH__EXTRA = "morph__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__morph__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__morph__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MORPH__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__morph__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__morph__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROLLER__EXTRA = "controller__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__controller__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONTROLLER__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__controller__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__controller__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__EXTRA = "library_controllers__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_controllers__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CONTROLLERS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_controllers__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_GEOMETRIES = "library_geometries";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_GEOMETRIES = "COLLADA__library_geometries";

//---------------------------------------------------------------------
const library_geometries__AttributeData library_geometries__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_geometries( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_geometries__AttributeData* attributeData = newData<library_geometries__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_GEOMETRIES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_geometries( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__ASSET = "library_geometries__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_geometries__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_geometries__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY = "geometry";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__GEOMETRY = "library_geometries__geometry";

//---------------------------------------------------------------------
const geometry__AttributeData geometry__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
geometry__AttributeData* attributeData = newData<geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GEOMETRY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__geometry( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY__ASSET = "geometry__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__geometry__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__geometry__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__geometry__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__geometry__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH = "convex_mesh";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY__CONVEX_MESH = "geometry__convex_mesh";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_CONVEX_HULL_OF = "convex_hull_of";

//---------------------------------------------------------------------
const convex_mesh__AttributeData convex_mesh__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__AttributeData* attributeData = newData<convex_mesh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONVEX_HULL_OF:
    {

attributeData->convex_hull_of = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__SOURCE = "convex_mesh__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__source__AttributeData* attributeData = newData<convex_mesh__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTICES = "vertices";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__VERTICES = "convex_mesh__vertices";

//---------------------------------------------------------------------
const vertices__AttributeData vertices__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__AttributeData* attributeData = newData<vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__VERTICES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__vertices()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTICES__INPUT = "vertices__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertices__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__input__AttributeData* attributeData = newData<vertices__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTICES__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertices__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertices__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VERTICES__EXTRA = "vertices__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__vertices__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTICES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__vertices__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__vertices__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINES = "lines";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__LINES = "convex_mesh__lines";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_MATERIAL = "material";

//---------------------------------------------------------------------
const lines__AttributeData lines__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__AttributeData* attributeData = newData<lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINES, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__LINES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__lines()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__lines( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINES__INPUT = "lines__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lines__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lines__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__input__AttributeData* attributeData = newData<lines__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINES__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lines__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lines__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_P = "p";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINES__P = "lines__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lines__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__lines__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lines__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lines__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__lines__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lines__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINES__EXTRA = "lines__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lines__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lines__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lines__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lines__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINESTRIPS = "linestrips";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__LINESTRIPS = "convex_mesh__linestrips";

//---------------------------------------------------------------------
const linestrips__AttributeData linestrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__AttributeData* attributeData = newData<linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINESTRIPS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__LINESTRIPS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__linestrips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__linestrips( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINESTRIPS__INPUT = "linestrips__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linestrips__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__input__AttributeData* attributeData = newData<linestrips__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINESTRIPS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linestrips__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINESTRIPS__P = "linestrips__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linestrips__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__linestrips__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__linestrips__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linestrips__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINESTRIPS__EXTRA = "linestrips__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linestrips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINESTRIPS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linestrips__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGONS = "polygons";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__POLYGONS = "convex_mesh__polygons";

//---------------------------------------------------------------------
const polygons__AttributeData polygons__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__AttributeData* attributeData = newData<polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYGONS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__POLYGONS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__polygons()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__polygons( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGONS__INPUT = "polygons__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polygons__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polygons__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__input__AttributeData* attributeData = newData<polygons__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGONS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polygons__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polygons__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGONS__P = "polygons__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polygons__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__polygons__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polygons__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polygons__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__polygons__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polygons__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PH = "ph";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGONS__PH = "polygons__ph";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ph()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ph( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PH__P = "ph__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ph__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__ph__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ph__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ph__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__ph__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ph__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_H = "h";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PH__H = "ph__h";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__h( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__h);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__h( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__h()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__h );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__h( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYGONS__EXTRA = "polygons__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polygons__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polygons__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGONS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polygons__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polygons__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYLIST = "polylist";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__POLYLIST = "convex_mesh__polylist";

//---------------------------------------------------------------------
const polylist__AttributeData polylist__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__AttributeData* attributeData = newData<polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYLIST, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__POLYLIST, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__polylist()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__polylist( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYLIST__INPUT = "polylist__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polylist__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polylist__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__input__AttributeData* attributeData = newData<polylist__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYLIST__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polylist__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polylist__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYLIST__VCOUNT = "polylist__vcount";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polylist__vcount( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__polylist__vcount);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polylist__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polylist__vcount()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__polylist__vcount );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polylist__vcount( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYLIST__P = "polylist__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polylist__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__polylist__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polylist__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polylist__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__polylist__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polylist__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POLYLIST__EXTRA = "polylist__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__polylist__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__polylist__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYLIST__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__polylist__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__polylist__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIANGLES = "triangles";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__TRIANGLES = "convex_mesh__triangles";

//---------------------------------------------------------------------
const triangles__AttributeData triangles__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__AttributeData* attributeData = newData<triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIANGLES, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__TRIANGLES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__triangles()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__triangles( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIANGLES__INPUT = "triangles__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__triangles__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__triangles__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__input__AttributeData* attributeData = newData<triangles__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIANGLES__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__triangles__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__triangles__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIANGLES__P = "triangles__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__triangles__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__triangles__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__triangles__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__triangles__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__triangles__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__triangles__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIANGLES__EXTRA = "triangles__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__triangles__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__triangles__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIANGLES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__triangles__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__triangles__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIFANS = "trifans";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__TRIFANS = "convex_mesh__trifans";

//---------------------------------------------------------------------
const trifans__AttributeData trifans__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__AttributeData* attributeData = newData<trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIFANS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__TRIFANS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__trifans()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__trifans( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIFANS__INPUT = "trifans__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__trifans__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__trifans__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__input__AttributeData* attributeData = newData<trifans__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIFANS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__trifans__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__trifans__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIFANS__P = "trifans__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__trifans__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__trifans__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__trifans__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__trifans__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__trifans__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__trifans__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRIFANS__EXTRA = "trifans__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__trifans__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__trifans__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIFANS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__trifans__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__trifans__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRISTRIPS = "tristrips";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__TRISTRIPS = "convex_mesh__tristrips";

//---------------------------------------------------------------------
const tristrips__AttributeData tristrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__AttributeData* attributeData = newData<tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRISTRIPS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__TRISTRIPS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__tristrips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__tristrips( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRISTRIPS__INPUT = "tristrips__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tristrips__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__input__AttributeData* attributeData = newData<tristrips__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__INPUT, HASH_ATTRIBUTE_OFFSET, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__INPUT, HASH_ATTRIBUTE_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRISTRIPS__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tristrips__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRISTRIPS__P = "tristrips__p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tristrips__p( const ParserChar* text, size_t textLength )
{
return characterData2UnsignedLongLongData(text, textLength, &ColladaParserAutoGen::data__tristrips__p);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__p()
{
return unsignedLongLongDataEnd( &ColladaParserAutoGen::data__tristrips__p );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tristrips__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRISTRIPS__EXTRA = "tristrips__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tristrips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRISTRIPS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tristrips__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONVEX_MESH__EXTRA = "convex_mesh__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__convex_mesh__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__convex_mesh__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH = "mesh";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY__MESH = "geometry__mesh";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__SOURCE = "mesh__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__source__AttributeData* attributeData = newData<mesh__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__VERTICES = "mesh__vertices";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__AttributeData* attributeData = newData<vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__VERTICES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__vertices()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__LINES = "mesh__lines";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__AttributeData* attributeData = newData<lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINES, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__LINES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__lines()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__lines( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__LINESTRIPS = "mesh__linestrips";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__AttributeData* attributeData = newData<linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINESTRIPS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__LINESTRIPS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__linestrips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__linestrips( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__POLYGONS = "mesh__polygons";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__AttributeData* attributeData = newData<polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYGONS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__POLYGONS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__polygons()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__polygons( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__POLYLIST = "mesh__polylist";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__AttributeData* attributeData = newData<polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYLIST, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__POLYLIST, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__polylist()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__polylist( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__TRIANGLES = "mesh__triangles";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__AttributeData* attributeData = newData<triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIANGLES, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__TRIANGLES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__triangles()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__triangles( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__TRIFANS = "mesh__trifans";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__AttributeData* attributeData = newData<trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIFANS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__TRIFANS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__trifans()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__trifans( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__TRISTRIPS = "mesh__tristrips";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__AttributeData* attributeData = newData<tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRISTRIPS, HASH_ATTRIBUTE_COUNT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__TRISTRIPS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__tristrips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__tristrips( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MESH__EXTRA = "mesh__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mesh__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MESH__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mesh__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mesh__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPLINE = "spline";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY__SPLINE = "geometry__spline";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_CLOSED = "closed";

//---------------------------------------------------------------------
const spline__AttributeData spline__AttributeData::DEFAULT = {false};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spline__AttributeData* attributeData = newData<spline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLOSED:
    {
bool failed;
attributeData->closed = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE, HASH_ATTRIBUTE_CLOSED, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPLINE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spline()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPLINE__SOURCE = "spline__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spline__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spline__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spline__source__AttributeData* attributeData = newData<spline__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPLINE__SOURCE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spline__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spline__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROL_VERTICES = "control_vertices";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPLINE__CONTROL_VERTICES = "spline__control_vertices";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__control_vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__control_vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROL_VERTICES__INPUT = "control_vertices__input";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__control_vertices__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
control_vertices__input__AttributeData* attributeData = newData<control_vertices__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONTROL_VERTICES__INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__control_vertices__input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONTROL_VERTICES__EXTRA = "control_vertices__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__control_vertices__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONTROL_VERTICES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__control_vertices__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPLINE__EXTRA = "spline__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spline__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPLINE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spline__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spline__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GEOMETRY__EXTRA = "geometry__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__geometry__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GEOMETRY__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__geometry__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__geometry__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__EXTRA = "library_geometries__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_geometries__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_GEOMETRIES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_geometries__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_EFFECTS = "library_effects";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_EFFECTS = "COLLADA__library_effects";

//---------------------------------------------------------------------
const library_effects__AttributeData library_effects__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_effects( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_effects( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_effects__AttributeData* attributeData = newData<library_effects__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_EFFECTS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_effects()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_effects( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_EFFECTS__ASSET = "library_effects__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_effects__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_effects__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_effects__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_effects__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT = "effect";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_EFFECTS__EFFECT = "library_effects__effect";

//---------------------------------------------------------------------
const effect__AttributeData effect__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__AttributeData* attributeData = newData<effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__ASSET = "effect__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__ANNOTATE = "effect__annotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__IMAGE = "effect__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__NEWPARAM = "effect__newparam";

//---------------------------------------------------------------------
const effect__newparam__AttributeData effect__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__newparam__AttributeData* attributeData = newData<effect__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D = "sampler1D";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLER1D = "newparam__sampler1D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__sampler1D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__SOURCE = "sampler1D__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__sampler1D__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__WRAP_S = "sampler1D__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_sampler_wrap_common ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_sampler_wrap_common (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_sampler_wrap_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT, &toEnum_fx_sampler_wrap_common>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_sampler_wrap_common (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_sampler_wrap_common*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>(text, textLength, dataFunction, fx_sampler_wrap_commonMap, baseConversionFunc, &toEnum_fx_sampler_wrap_common, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_sampler_wrap_common);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_sampler_wrap_common (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_sampler_wrap_common*, size_t ),
    const std::pair<StringHash, fx_sampler_wrap_common>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_sampler_wrap_common (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_sampler_wrap_common>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__MINFILTER = "sampler1D__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__MAGFILTER = "sampler1D__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__MIPFILTER = "sampler1D__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BORDER_COLOR = "border_color";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__BORDER_COLOR = "sampler1D__border_color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__border_color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler1D__border_color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__border_color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__sampler1D__border_color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__MIPMAP_MAXLEVEL = "sampler1D__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__MIPMAP_BIAS = "sampler1D__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler1D__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER1D__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER1D__EXTRA = "sampler1D__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler1D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER1D__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler1D__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D = "sampler2D";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLER2D = "newparam__sampler2D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__sampler2D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__SOURCE = "sampler2D__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__sampler2D__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__WRAP_S = "sampler2D__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__WRAP_T = "sampler2D__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__wrap_t()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__MINFILTER = "sampler2D__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__MAGFILTER = "sampler2D__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__MIPFILTER = "sampler2D__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__BORDER_COLOR = "sampler2D__border_color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__border_color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler2D__border_color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__border_color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__sampler2D__border_color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__MIPMAP_MAXLEVEL = "sampler2D__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__MIPMAP_BIAS = "sampler2D__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler2D__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER2D__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER2D__EXTRA = "sampler2D__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler2D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER2D__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler2D__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D = "sampler3D";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLER3D = "newparam__sampler3D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__sampler3D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__SOURCE = "sampler3D__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__sampler3D__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__WRAP_S = "sampler3D__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__WRAP_T = "sampler3D__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_t()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_WRAP_P = "wrap_p";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__WRAP_P = "sampler3D__wrap_p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_p( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_p()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__wrap_p(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__WRAP_P, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__wrap_p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__MINFILTER = "sampler3D__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__MAGFILTER = "sampler3D__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__MIPFILTER = "sampler3D__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__BORDER_COLOR = "sampler3D__border_color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__border_color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler3D__border_color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__border_color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__sampler3D__border_color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__MIPMAP_MAXLEVEL = "sampler3D__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__MIPMAP_BIAS = "sampler3D__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sampler3D__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLER3D__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLER3D__EXTRA = "sampler3D__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sampler3D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER3D__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sampler3D__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE = "samplerCUBE";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLERCUBE = "newparam__samplerCUBE";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__samplerCUBE( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__SOURCE = "samplerCUBE__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__samplerCUBE__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_S = "samplerCUBE__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_T = "samplerCUBE__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_t()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_P = "samplerCUBE__wrap_p";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_p( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_p()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__wrap_p(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__WRAP_P, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__wrap_p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__MINFILTER = "samplerCUBE__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__MAGFILTER = "samplerCUBE__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__MIPFILTER = "samplerCUBE__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__BORDER_COLOR = "samplerCUBE__border_color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__border_color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerCUBE__border_color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__border_color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__samplerCUBE__border_color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__MIPMAP_MAXLEVEL = "samplerCUBE__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__MIPMAP_BIAS = "samplerCUBE__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerCUBE__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERCUBE__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERCUBE__EXTRA = "samplerCUBE__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerCUBE__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLERCUBE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerCUBE__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT = "samplerRECT";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLERRECT = "newparam__samplerRECT";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__samplerRECT( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__SOURCE = "samplerRECT__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__samplerRECT__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__WRAP_S = "samplerRECT__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__WRAP_T = "samplerRECT__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__wrap_t()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__MINFILTER = "samplerRECT__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__MAGFILTER = "samplerRECT__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__MIPFILTER = "samplerRECT__mipfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__mipfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__MIPFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__BORDER_COLOR = "samplerRECT__border_color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__border_color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerRECT__border_color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__border_color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__samplerRECT__border_color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__MIPMAP_MAXLEVEL = "samplerRECT__mipmap_maxlevel";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipmap_maxlevel()
{
bool failed;
unsigned short parameter = GeneratedSaxParser::Utils::toUnsignedShort((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__mipmap_maxlevel(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__MIPMAP_MAXLEVEL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__mipmap_maxlevel( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__MIPMAP_BIAS = "samplerRECT__mipmap_bias";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipmap_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipmap_bias()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerRECT__mipmap_bias(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERRECT__MIPMAP_BIAS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__mipmap_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERRECT__EXTRA = "samplerRECT__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerRECT__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLERRECT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerRECT__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH = "samplerDEPTH";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__SAMPLERDEPTH = "newparam__samplerDEPTH";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__samplerDEPTH( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__SOURCE = "samplerDEPTH__source";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__source( const ParserChar* text, size_t textLength )
{
return mImpl->data__samplerDEPTH__source(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__source( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__WRAP_S = "samplerDEPTH__wrap_s";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__wrap_s( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__wrap_s()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerDEPTH__wrap_s(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERDEPTH__WRAP_S, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__wrap_s( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__WRAP_T = "samplerDEPTH__wrap_t";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__wrap_t( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__wrap_t()
{
bool failed;
fx_sampler_wrap_common parameter = Utils::toEnum<fx_sampler_wrap_common, StringHash, fx_sampler_wrap_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_wrap_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerDEPTH__wrap_t(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERDEPTH__WRAP_T, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__wrap_t( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__MINFILTER = "samplerDEPTH__minfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__minfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerDEPTH__minfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERDEPTH__MINFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__MAGFILTER = "samplerDEPTH__magfilter";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__magfilter()
{
bool failed;
fx_sampler_filter_common parameter = Utils::toEnum<fx_sampler_filter_common, StringHash, fx_sampler_filter_common__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, fx_sampler_filter_commonMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__samplerDEPTH__magfilter(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SAMPLERDEPTH__MAGFILTER, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SAMPLERDEPTH__EXTRA = "samplerDEPTH__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLERDEPTH__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__samplerDEPTH__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FX_PROFILE_ABSTRACT = "fx_profile_abstract";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__FX_PROFILE_ABSTRACT = "effect__fx_profile_abstract";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__fx_profile_abstract( const ParserChar* text, size_t textLength )
{
return mImpl->data__fx_profile_abstract(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__fx_profile_abstract( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__fx_profile_abstract()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__fx_profile_abstract( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EFFECT__EXTRA = "effect__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__effect__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__effect__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__effect__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_EFFECTS__EXTRA = "library_effects__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_effects__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_effects__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_EFFECTS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_effects__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_effects__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS = "library_force_fields";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_FORCE_FIELDS = "COLLADA__library_force_fields";

//---------------------------------------------------------------------
const library_force_fields__AttributeData library_force_fields__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_force_fields( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_force_fields__AttributeData* attributeData = newData<library_force_fields__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_FORCE_FIELDS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_force_fields( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__ASSET = "library_force_fields__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_force_fields__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_force_fields__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORCE_FIELD = "force_field";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__FORCE_FIELD = "library_force_fields__force_field";

//---------------------------------------------------------------------
const force_field__AttributeData force_field__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
force_field__AttributeData* attributeData = newData<force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORCE_FIELD, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__force_field()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__force_field( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORCE_FIELD__ASSET = "force_field__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__force_field__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__force_field__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__force_field__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__force_field__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORCE_FIELD__TECHNIQUE = "force_field__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__force_field__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__force_field__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
force_field__technique__AttributeData* attributeData = newData<force_field__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORCE_FIELD__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__force_field__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__force_field__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FORCE_FIELD__EXTRA = "force_field__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__force_field__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORCE_FIELD__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__force_field__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__force_field__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__EXTRA = "library_force_fields__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_force_fields__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_FORCE_FIELDS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_force_fields__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_IMAGES = "library_images";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_IMAGES = "COLLADA__library_images";

//---------------------------------------------------------------------
const library_images__AttributeData library_images__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_images( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_images( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_images__AttributeData* attributeData = newData<library_images__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_IMAGES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_images()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_images( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_IMAGES__ASSET = "library_images__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_images__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_images__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_images__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_images__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_IMAGES__IMAGE = "library_images__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_images__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_images__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_IMAGES__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_images__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_images__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_IMAGES__EXTRA = "library_images__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_images__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_images__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_IMAGES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_images__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_images__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_LIGHTS = "library_lights";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_LIGHTS = "COLLADA__library_lights";

//---------------------------------------------------------------------
const library_lights__AttributeData library_lights__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_lights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_lights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_lights__AttributeData* attributeData = newData<library_lights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_LIGHTS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_lights()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_lights( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_LIGHTS__ASSET = "library_lights__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_lights__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_lights__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_lights__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_lights__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT = "light";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_LIGHTS__LIGHT = "library_lights__light";

//---------------------------------------------------------------------
const light__AttributeData light__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light__AttributeData* attributeData = newData<light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT__ASSET = "light__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT__TECHNIQUE_COMMON = "light__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AMBIENT = "ambient";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__AMBIENT = "technique_common__ambient";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique_common__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique_common__ambient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLOR = "color";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AMBIENT__COLOR = "ambient__color";

//---------------------------------------------------------------------
const ambient__color__AttributeData ambient__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ambient__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ambient__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ambient__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ambient__color__AttributeData* attributeData = newData<ambient__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AMBIENT__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ambient__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__ambient__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ambient__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIRECTIONAL = "directional";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__DIRECTIONAL = "technique_common__directional";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__directional( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__directional( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__directional()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__directional( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIRECTIONAL__COLOR = "directional__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__directional__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__directional__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__directional__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
directional__color__AttributeData* attributeData = newData<directional__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DIRECTIONAL__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__directional__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__directional__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__directional__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT = "point";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__POINT = "technique_common__point";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT__COLOR = "point__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__point__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point__color__AttributeData* attributeData = newData<point__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__point__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT_ATTENUATION = "constant_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT__CONSTANT_ATTENUATION = "point__constant_attenuation";

//---------------------------------------------------------------------
const constant_attenuation__AttributeData constant_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point__constant_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
constant_attenuation__AttributeData* attributeData = newData<constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT__CONSTANT_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point__constant_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__point__constant_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_POINT__CONSTANT_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point__constant_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR_ATTENUATION = "linear_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT__LINEAR_ATTENUATION = "point__linear_attenuation";

//---------------------------------------------------------------------
const linear_attenuation__AttributeData linear_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point__linear_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear_attenuation__AttributeData* attributeData = newData<linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT__LINEAR_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point__linear_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__point__linear_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_POINT__LINEAR_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point__linear_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_QUADRATIC_ATTENUATION = "quadratic_attenuation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_POINT__QUADRATIC_ATTENUATION = "point__quadratic_attenuation";

//---------------------------------------------------------------------
const quadratic_attenuation__AttributeData quadratic_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__point__quadratic_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__point__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
quadratic_attenuation__AttributeData* attributeData = newData<quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT__QUADRATIC_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__point__quadratic_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__point__quadratic_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_POINT__QUADRATIC_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__point__quadratic_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT = "spot";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__SPOT = "technique_common__spot";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spot( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spot()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spot( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__COLOR = "spot__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spot__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__spot__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spot__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spot__color__AttributeData* attributeData = newData<spot__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPOT__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spot__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__spot__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spot__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__CONSTANT_ATTENUATION = "spot__constant_attenuation";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spot__constant_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spot__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
constant_attenuation__AttributeData* attributeData = newData<constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPOT__CONSTANT_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spot__constant_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__spot__constant_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SPOT__CONSTANT_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spot__constant_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__LINEAR_ATTENUATION = "spot__linear_attenuation";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spot__linear_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spot__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear_attenuation__AttributeData* attributeData = newData<linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPOT__LINEAR_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spot__linear_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__spot__linear_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SPOT__LINEAR_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spot__linear_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__QUADRATIC_ATTENUATION = "spot__quadratic_attenuation";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spot__quadratic_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spot__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
quadratic_attenuation__AttributeData* attributeData = newData<quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPOT__QUADRATIC_ATTENUATION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spot__quadratic_attenuation()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__spot__quadratic_attenuation(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SPOT__QUADRATIC_ATTENUATION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spot__quadratic_attenuation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FALLOFF_ANGLE = "falloff_angle";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__FALLOFF_ANGLE = "spot__falloff_angle";

//---------------------------------------------------------------------
const falloff_angle__AttributeData falloff_angle__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__falloff_angle( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__falloff_angle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
falloff_angle__AttributeData* attributeData = newData<falloff_angle__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FALLOFF_ANGLE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__falloff_angle()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__falloff_angle(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FALLOFF_ANGLE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__falloff_angle( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FALLOFF_EXPONENT = "falloff_exponent";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPOT__FALLOFF_EXPONENT = "spot__falloff_exponent";

//---------------------------------------------------------------------
const falloff_exponent__AttributeData falloff_exponent__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__falloff_exponent( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__falloff_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
falloff_exponent__AttributeData* attributeData = newData<falloff_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FALLOFF_EXPONENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__falloff_exponent()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__falloff_exponent(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FALLOFF_EXPONENT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__falloff_exponent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT__TECHNIQUE = "light__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light__technique__AttributeData* attributeData = newData<light__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIGHT__EXTRA = "light__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__light__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__light__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__light__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_LIGHTS__EXTRA = "library_lights__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_lights__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_lights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_LIGHTS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_lights__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_lights__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_MATERIALS = "library_materials";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_MATERIALS = "COLLADA__library_materials";

//---------------------------------------------------------------------
const library_materials__AttributeData library_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_materials__AttributeData* attributeData = newData<library_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_MATERIALS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_materials()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_materials( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_MATERIALS__ASSET = "library_materials__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_materials__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_materials__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_materials__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL = "material";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_MATERIALS__MATERIAL = "library_materials__material";

//---------------------------------------------------------------------
const material__AttributeData material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material__AttributeData* attributeData = newData<material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL__ASSET = "material__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_EFFECT = "instance_effect";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL__INSTANCE_EFFECT = "material__instance_effect";

//---------------------------------------------------------------------
const instance_effect__AttributeData instance_effect__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__AttributeData* attributeData = newData<instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL__INSTANCE_EFFECT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material__instance_effect()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material__instance_effect( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_HINT = "technique_hint";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_EFFECT__TECHNIQUE_HINT = "instance_effect__technique_hint";

//---------------------------------------------------------------------
const technique_hint__AttributeData technique_hint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique_hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique_hint__AttributeData* attributeData = newData<technique_hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_HINT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique_hint()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique_hint( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_EFFECT__SETPARAM = "instance_effect__setparam";

//---------------------------------------------------------------------
const instance_effect__setparam__AttributeData instance_effect__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_effect__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_effect__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__setparam__AttributeData* attributeData = newData<instance_effect__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_EFFECT__SETPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_effect__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_effect__setparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLER1D = "setparam__sampler1D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__sampler1D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLER2D = "setparam__sampler2D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__sampler2D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLER3D = "setparam__sampler3D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__sampler3D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLERCUBE = "setparam__samplerCUBE";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__samplerCUBE( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLERRECT = "setparam__samplerRECT";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__samplerRECT( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__SAMPLERDEPTH = "setparam__samplerDEPTH";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__samplerDEPTH( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_EFFECT__EXTRA = "instance_effect__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_effect__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_EFFECT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_effect__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_effect__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATERIAL__EXTRA = "material__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__material__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_MATERIALS__EXTRA = "library_materials__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_materials__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_MATERIALS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_materials__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_materials__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_NODES = "library_nodes";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_NODES = "COLLADA__library_nodes";

//---------------------------------------------------------------------
const library_nodes__AttributeData library_nodes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_nodes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_nodes__AttributeData* attributeData = newData<library_nodes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_NODES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_nodes( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_NODES__ASSET = "library_nodes__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_nodes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_nodes__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE = "node";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_NODES__NODE = "library_nodes__node";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_LAYER = "layer";

//---------------------------------------------------------------------
const node__AttributeData node__AttributeData::DEFAULT = {0, 0, 0, NodeType__NODE, (const GeneratedSaxParser::ParserChar *)""};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_nodes__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<NodeType, StringHash, NodeType__COUNT>(attributeValue, failed, NodeTypeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES__NODE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {

attributeData->layer = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_NODES__NODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__node()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_nodes__node( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
NodeType ColladaParserAutoGenPrivate::toEnumDataPrefix_NodeType (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, NodeType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<NodeType, StringHash, NodeType__COUNT, &toEnum_NodeType>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_NodeType (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const NodeType*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<NodeType, StringHash, NodeType__COUNT>(text, textLength, dataFunction, NodeTypeMap, baseConversionFunc, &toEnum_NodeType, &ColladaParserAutoGenPrivate::toEnumDataPrefix_NodeType);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_NodeType (
    bool ( ColladaParserAutoGen::*dataFunction )(const NodeType*, size_t ),
    const std::pair<StringHash, NodeType>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    NodeType (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, NodeType>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<NodeType, StringHash, NodeType__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__ASSET = "node__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LOOKAT = "lookat";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__LOOKAT = "node__lookat";

//---------------------------------------------------------------------
const lookat__AttributeData lookat__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lookat( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__lookat);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lookat( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lookat__AttributeData* attributeData = newData<lookat__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOOKAT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lookat()
{
return doubleDataEnd( &ColladaParserAutoGen::data__lookat );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lookat( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MATRIX = "matrix";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__MATRIX = "node__matrix";

//---------------------------------------------------------------------
const matrix__AttributeData matrix__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__matrix( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__matrix);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
matrix__AttributeData* attributeData = newData<matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATRIX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__matrix()
{
return doubleDataEnd( &ColladaParserAutoGen::data__matrix );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__matrix( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ROTATE = "rotate";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__ROTATE = "node__rotate";

//---------------------------------------------------------------------
const rotate__AttributeData rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__rotate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__node__rotate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE__ROTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__rotate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__node__rotate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__rotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCALE = "scale";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__SCALE = "node__scale";

//---------------------------------------------------------------------
const scale__AttributeData scale__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__scale( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__scale);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__scale( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scale__AttributeData* attributeData = newData<scale__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCALE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__scale()
{
return doubleDataEnd( &ColladaParserAutoGen::data__scale );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__scale( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKEW = "skew";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__SKEW = "node__skew";

//---------------------------------------------------------------------
const skew__AttributeData skew__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__skew( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__skew);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__skew( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skew__AttributeData* attributeData = newData<skew__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKEW, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__skew()
{
return doubleDataEnd( &ColladaParserAutoGen::data__skew );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__skew( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSLATE = "translate";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__TRANSLATE = "node__translate";

//---------------------------------------------------------------------
const translate__AttributeData translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__translate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__node__translate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE__TRANSLATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__translate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__node__translate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__translate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CAMERA = "instance_camera";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__INSTANCE_CAMERA = "node__instance_camera";

//---------------------------------------------------------------------
const instance_camera__AttributeData instance_camera__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_camera__AttributeData* attributeData = newData<instance_camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CAMERA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_camera()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_camera( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CAMERA__EXTRA = "instance_camera__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_camera__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CAMERA__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_camera__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_camera__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CONTROLLER = "instance_controller";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__INSTANCE_CONTROLLER = "node__instance_controller";

//---------------------------------------------------------------------
const instance_controller__AttributeData instance_controller__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_controller__AttributeData* attributeData = newData<instance_controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CONTROLLER, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_controller( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SKELETON = "skeleton";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CONTROLLER__SKELETON = "instance_controller__skeleton";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__skeleton( const ParserChar* text, size_t textLength )
{
return mImpl->data__skeleton(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__skeleton( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__skeleton()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__skeleton( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_MATERIAL = "bind_material";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CONTROLLER__BIND_MATERIAL = "instance_controller__bind_material";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_controller__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller__bind_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_controller__bind_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_MATERIAL__PARAM = "bind_material__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_material__param( const ParserChar* text, size_t textLength )
{
return mImpl->data__bind_material__param(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_material__param__AttributeData* attributeData = newData<bind_material__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_MATERIAL__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_material__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_MATERIAL__TECHNIQUE_COMMON = "bind_material__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_material__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_material__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_MATERIAL = "instance_material";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__INSTANCE_MATERIAL = "technique_common__instance_material";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_SYMBOL = "symbol";

//---------------------------------------------------------------------
const instance_material__AttributeData instance_material__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_material__AttributeData* attributeData = newData<instance_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND = "bind";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_MATERIAL__BIND = "instance_material__bind";

//---------------------------------------------------------------------
const instance_material__bind__AttributeData instance_material__bind__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_material__bind( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_material__bind( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_material__bind__AttributeData* attributeData = newData<instance_material__bind__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_MATERIAL__BIND, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_material__bind()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_material__bind( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_VERTEX_INPUT = "bind_vertex_input";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_MATERIAL__BIND_VERTEX_INPUT = "instance_material__bind_vertex_input";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_INPUT_SEMANTIC = "input_semantic";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_INPUT_SET = "input_set";

//---------------------------------------------------------------------
const bind_vertex_input__AttributeData bind_vertex_input__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_vertex_input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_vertex_input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_vertex_input__AttributeData* attributeData = newData<bind_vertex_input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SEMANTIC:
    {

attributeData->input_semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SET:
    {
bool failed;
attributeData->input_set = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_VERTEX_INPUT, HASH_ATTRIBUTE_INPUT_SET, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_VERTEX_INPUT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_vertex_input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_vertex_input( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_MATERIAL__EXTRA = "instance_material__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_MATERIAL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_material__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_MATERIAL__TECHNIQUE = "bind_material__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_material__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_material__technique__AttributeData* attributeData = newData<bind_material__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_MATERIAL__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_material__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BIND_MATERIAL__EXTRA = "bind_material__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__bind_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_MATERIAL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__bind_material__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_CONTROLLER__EXTRA = "instance_controller__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_controller__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CONTROLLER__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_controller__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_GEOMETRY = "instance_geometry";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__INSTANCE_GEOMETRY = "node__instance_geometry";

//---------------------------------------------------------------------
const instance_geometry__AttributeData instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_geometry__AttributeData* attributeData = newData<instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE__INSTANCE_GEOMETRY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__instance_geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__instance_geometry( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_GEOMETRY__BIND_MATERIAL = "instance_geometry__bind_material";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_geometry__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_geometry__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_geometry__bind_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_geometry__bind_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_GEOMETRY__EXTRA = "instance_geometry__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_geometry__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_GEOMETRY__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_geometry__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_geometry__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_LIGHT = "instance_light";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__INSTANCE_LIGHT = "node__instance_light";

//---------------------------------------------------------------------
const instance_light__AttributeData instance_light__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_light__AttributeData* attributeData = newData<instance_light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_LIGHT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_light()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_light( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_LIGHT__EXTRA = "instance_light__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_light__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_LIGHT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_light__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_light__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_NODE = "instance_node";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__INSTANCE_NODE = "node__instance_node";

//---------------------------------------------------------------------
const instance_node__AttributeData instance_node__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_node__AttributeData* attributeData = newData<instance_node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_NODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_node()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_node( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_NODE__EXTRA = "instance_node__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_node__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_NODE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_node__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_node__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__NODE = "node__node";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<NodeType, StringHash, NodeType__COUNT>(attributeValue, failed, NodeTypeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__NODE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {

attributeData->layer = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE__NODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__node()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__node( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NODE__EXTRA = "node__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__node__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__node__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__node__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_NODES__EXTRA = "library_nodes__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_nodes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_NODES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_nodes__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS = "library_physics_materials";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_MATERIALS = "COLLADA__library_physics_materials";

//---------------------------------------------------------------------
const library_physics_materials__AttributeData library_physics_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_materials__AttributeData* attributeData = newData<library_physics_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_materials( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__ASSET = "library_physics_materials__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_materials__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_materials__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MATERIAL = "physics_material";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__PHYSICS_MATERIAL = "library_physics_materials__physics_material";

//---------------------------------------------------------------------
const physics_material__AttributeData physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_materials__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__PHYSICS_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_materials__physics_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MATERIAL__ASSET = "physics_material__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_material__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_material__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE_COMMON = "physics_material__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_material__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_material__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DYNAMIC_FRICTION = "dynamic_friction";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__DYNAMIC_FRICTION = "technique_common__dynamic_friction";

//---------------------------------------------------------------------
const dynamic_friction__AttributeData dynamic_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__dynamic_friction( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__dynamic_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dynamic_friction__AttributeData* attributeData = newData<dynamic_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DYNAMIC_FRICTION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__dynamic_friction()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__dynamic_friction(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DYNAMIC_FRICTION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__dynamic_friction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RESTITUTION = "restitution";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__RESTITUTION = "technique_common__restitution";

//---------------------------------------------------------------------
const restitution__AttributeData restitution__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__restitution( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__restitution( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
restitution__AttributeData* attributeData = newData<restitution__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RESTITUTION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__restitution()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__restitution(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_RESTITUTION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__restitution( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STATIC_FRICTION = "static_friction";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__STATIC_FRICTION = "technique_common__static_friction";

//---------------------------------------------------------------------
const static_friction__AttributeData static_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__static_friction( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__static_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
static_friction__AttributeData* attributeData = newData<static_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STATIC_FRICTION, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__static_friction()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__static_friction(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_STATIC_FRICTION, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__static_friction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE = "physics_material__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_material__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__technique__AttributeData* attributeData = newData<physics_material__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_material__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MATERIAL__EXTRA = "physics_material__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MATERIAL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_material__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__EXTRA = "library_physics_materials__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_materials__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_materials__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS = "library_physics_models";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_MODELS = "COLLADA__library_physics_models";

//---------------------------------------------------------------------
const library_physics_models__AttributeData library_physics_models__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_models( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_models__AttributeData* attributeData = newData<library_physics_models__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MODELS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_models( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__ASSET = "library_physics_models__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_models__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_models__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL = "physics_model";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__PHYSICS_MODEL = "library_physics_models__physics_model";

//---------------------------------------------------------------------
const physics_model__AttributeData physics_model__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_model__AttributeData* attributeData = newData<physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MODEL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_model( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL__ASSET = "physics_model__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_model__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_model__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_BODY = "rigid_body";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL__RIGID_BODY = "physics_model__rigid_body";

//---------------------------------------------------------------------
const rigid_body__AttributeData rigid_body__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_body__AttributeData* attributeData = newData<rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_BODY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_body( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON = "rigid_body__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_body__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_body__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DYNAMIC = "dynamic";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__DYNAMIC = "technique_common__dynamic";

//---------------------------------------------------------------------
const dynamic__AttributeData dynamic__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__dynamic( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__dynamic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dynamic__AttributeData* attributeData = newData<dynamic__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DYNAMIC, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__dynamic()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__dynamic(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DYNAMIC, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__dynamic( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MASS = "mass";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__MASS = "technique_common__mass";

//---------------------------------------------------------------------
const mass__AttributeData mass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique_common__mass( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mass__AttributeData* attributeData = newData<mass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_COMMON__MASS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__mass()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__technique_common__mass(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TECHNIQUE_COMMON__MASS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique_common__mass( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MASS_FRAME = "mass_frame";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__MASS_FRAME = "technique_common__mass_frame";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mass_frame( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mass_frame( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MASS_FRAME__TRANSLATE = "mass_frame__translate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mass_frame__translate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__mass_frame__translate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASS_FRAME__TRANSLATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame__translate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__mass_frame__translate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mass_frame__translate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MASS_FRAME__ROTATE = "mass_frame__rotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__mass_frame__rotate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__mass_frame__rotate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASS_FRAME__ROTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame__rotate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__mass_frame__rotate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__mass_frame__rotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INERTIA = "inertia";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__INERTIA = "technique_common__inertia";

//---------------------------------------------------------------------
const inertia__AttributeData inertia__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__inertia( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__inertia);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__inertia( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
inertia__AttributeData* attributeData = newData<inertia__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INERTIA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__inertia()
{
return doubleDataEnd( &ColladaParserAutoGen::data__inertia );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__inertia( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MATERIAL = "instance_physics_material";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__INSTANCE_PHYSICS_MATERIAL = "technique_common__instance_physics_material";

//---------------------------------------------------------------------
const instance_physics_material__AttributeData instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique_common__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_material__AttributeData* attributeData = newData<instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_COMMON__INSTANCE_PHYSICS_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__instance_physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique_common__instance_physics_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MATERIAL__EXTRA = "instance_physics_material__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_physics_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_physics_material__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__PHYSICS_MATERIAL = "technique_common__physics_material";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique_common__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_COMMON__PHYSICS_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique_common__physics_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE = "shape";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__SHAPE = "technique_common__shape";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HOLLOW = "hollow";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__HOLLOW = "shape__hollow";

//---------------------------------------------------------------------
const hollow__AttributeData hollow__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__hollow( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__hollow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
hollow__AttributeData* attributeData = newData<hollow__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HOLLOW, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__hollow()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__hollow(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_HOLLOW, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__hollow( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__MASS = "shape__mass";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__mass( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mass__AttributeData* attributeData = newData<mass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__MASS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__mass()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__shape__mass(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SHAPE__MASS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__mass( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DENSITY = "density";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__DENSITY = "shape__density";

//---------------------------------------------------------------------
const density__AttributeData density__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__density( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
density__AttributeData* attributeData = newData<density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DENSITY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__density()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__density(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DENSITY, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__density( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__INSTANCE_PHYSICS_MATERIAL = "shape__instance_physics_material";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_material__AttributeData* attributeData = newData<instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__INSTANCE_PHYSICS_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__instance_physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__instance_physics_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__PHYSICS_MATERIAL = "shape__physics_material";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__PHYSICS_MATERIAL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__physics_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__INSTANCE_GEOMETRY = "shape__instance_geometry";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_geometry__AttributeData* attributeData = newData<instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__INSTANCE_GEOMETRY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__instance_geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__instance_geometry( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PLANE = "plane";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__PLANE = "shape__plane";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__plane()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__plane( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EQUATION = "equation";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PLANE__EQUATION = "plane__equation";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__equation( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__equation);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__equation()
{
return doubleDataEnd( &ColladaParserAutoGen::data__equation );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__equation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PLANE__EXTRA = "plane__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__plane__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__plane__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PLANE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__plane__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__plane__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOX = "box";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__BOX = "shape__box";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__box( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__box( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__box()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__box( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF_EXTENTS = "half_extents";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOX__HALF_EXTENTS = "box__half_extents";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__half_extents( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__half_extents);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__half_extents( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__half_extents()
{
return doubleDataEnd( &ColladaParserAutoGen::data__half_extents );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__half_extents( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOX__EXTRA = "box__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__box__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__box__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BOX__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__box__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__box__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPHERE = "sphere";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__SPHERE = "shape__sphere";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sphere( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sphere( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sphere()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sphere( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RADIUS = "radius";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPHERE__RADIUS = "sphere__radius";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sphere__radius( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sphere__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sphere__radius()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__sphere__radius(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SPHERE__RADIUS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sphere__radius( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPHERE__EXTRA = "sphere__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__sphere__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__sphere__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPHERE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__sphere__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__sphere__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CYLINDER = "cylinder";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__CYLINDER = "shape__cylinder";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cylinder( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cylinder()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cylinder( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HEIGHT = "height";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CYLINDER__HEIGHT = "cylinder__height";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cylinder__height( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__height()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__cylinder__height(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_CYLINDER__HEIGHT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cylinder__height( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CYLINDER__RADIUS = "cylinder__radius";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cylinder__radius( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__cylinder__radius);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__radius()
{
return doubleDataEnd( &ColladaParserAutoGen::data__cylinder__radius );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cylinder__radius( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CYLINDER__EXTRA = "cylinder__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__cylinder__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CYLINDER__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__cylinder__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CYLINDER = "tapered_cylinder";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__TAPERED_CYLINDER = "shape__tapered_cylinder";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_cylinder( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_cylinder( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CYLINDER__HEIGHT = "tapered_cylinder__height";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__height( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__height()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__tapered_cylinder__height(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TAPERED_CYLINDER__HEIGHT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_cylinder__height( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RADIUS1 = "radius1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CYLINDER__RADIUS1 = "tapered_cylinder__radius1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__radius1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_cylinder__radius1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__radius1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__tapered_cylinder__radius1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_cylinder__radius1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RADIUS2 = "radius2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CYLINDER__RADIUS2 = "tapered_cylinder__radius2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__radius2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_cylinder__radius2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__radius2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__tapered_cylinder__radius2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_cylinder__radius2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CYLINDER__EXTRA = "tapered_cylinder__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TAPERED_CYLINDER__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_cylinder__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAPSULE = "capsule";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__CAPSULE = "shape__capsule";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__capsule( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__capsule()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__capsule( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAPSULE__HEIGHT = "capsule__height";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__capsule__height( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__capsule__height()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__capsule__height(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_CAPSULE__HEIGHT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__capsule__height( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAPSULE__RADIUS = "capsule__radius";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__capsule__radius( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__capsule__radius);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__capsule__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__capsule__radius()
{
return doubleDataEnd( &ColladaParserAutoGen::data__capsule__radius );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__capsule__radius( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CAPSULE__EXTRA = "capsule__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__capsule__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CAPSULE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__capsule__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__capsule__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CAPSULE = "tapered_capsule";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__TAPERED_CAPSULE = "shape__tapered_capsule";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_capsule( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_capsule( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CAPSULE__HEIGHT = "tapered_capsule__height";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_capsule__height( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__height()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__tapered_capsule__height(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TAPERED_CAPSULE__HEIGHT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_capsule__height( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CAPSULE__RADIUS1 = "tapered_capsule__radius1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_capsule__radius1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_capsule__radius1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__radius1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__tapered_capsule__radius1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_capsule__radius1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CAPSULE__RADIUS2 = "tapered_capsule__radius2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_capsule__radius2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_capsule__radius2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__radius2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__tapered_capsule__radius2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_capsule__radius2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TAPERED_CAPSULE__EXTRA = "tapered_capsule__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__tapered_capsule__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TAPERED_CAPSULE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__tapered_capsule__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__TRANSLATE = "shape__translate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__translate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shape__translate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__TRANSLATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__translate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__shape__translate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__translate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__ROTATE = "shape__rotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__rotate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shape__rotate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__ROTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__rotate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__shape__rotate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__rotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHAPE__EXTRA = "shape__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shape__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shape__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHAPE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shape__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shape__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE = "rigid_body__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_body__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_body__technique__AttributeData* attributeData = newData<rigid_body__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_BODY__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_body__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_BODY__EXTRA = "rigid_body__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_body__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_BODY__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_body__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT = "rigid_constraint";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL__RIGID_CONSTRAINT = "physics_model__rigid_constraint";

//---------------------------------------------------------------------
const rigid_constraint__AttributeData rigid_constraint__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_constraint__AttributeData* attributeData = newData<rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_CONSTRAINT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_constraint( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REF_ATTACHMENT = "ref_attachment";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT__REF_ATTACHMENT = "rigid_constraint__ref_attachment";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_RIGID_BODY = "rigid_body";

//---------------------------------------------------------------------
const ref_attachment__AttributeData ref_attachment__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ref_attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ref_attachment__AttributeData* attributeData = newData<ref_attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {

attributeData->rigid_body = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF_ATTACHMENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ref_attachment( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REF_ATTACHMENT__TRANSLATE = "ref_attachment__translate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ref_attachment__translate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ref_attachment__translate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF_ATTACHMENT__TRANSLATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__translate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__ref_attachment__translate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ref_attachment__translate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REF_ATTACHMENT__ROTATE = "ref_attachment__rotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ref_attachment__rotate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ref_attachment__rotate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF_ATTACHMENT__ROTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__rotate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__ref_attachment__rotate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ref_attachment__rotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REF_ATTACHMENT__EXTRA = "ref_attachment__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ref_attachment__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF_ATTACHMENT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ref_attachment__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ATTACHMENT = "attachment";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT__ATTACHMENT = "rigid_constraint__attachment";

//---------------------------------------------------------------------
const attachment__AttributeData attachment__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
attachment__AttributeData* attributeData = newData<attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {

attributeData->rigid_body = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__attachment()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__attachment( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ATTACHMENT__TRANSLATE = "attachment__translate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__attachment__translate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__attachment__translate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT__TRANSLATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__attachment__translate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__attachment__translate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__attachment__translate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ATTACHMENT__ROTATE = "attachment__rotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__attachment__rotate( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__attachment__rotate);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT__ROTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__attachment__rotate()
{
return doubleDataEnd( &ColladaParserAutoGen::data__attachment__rotate );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__attachment__rotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ATTACHMENT__EXTRA = "attachment__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__attachment__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__attachment__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__attachment__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE_COMMON = "rigid_constraint__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_constraint__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_constraint__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ENABLED = "enabled";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__ENABLED = "technique_common__enabled";

//---------------------------------------------------------------------
const enabled__AttributeData enabled__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__enabled( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__enabled( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
enabled__AttributeData* attributeData = newData<enabled__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ENABLED, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__enabled()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__enabled(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ENABLED, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__enabled( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INTERPENETRATE = "interpenetrate";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__INTERPENETRATE = "technique_common__interpenetrate";

//---------------------------------------------------------------------
const interpenetrate__AttributeData interpenetrate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__interpenetrate( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__interpenetrate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
interpenetrate__AttributeData* attributeData = newData<interpenetrate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INTERPENETRATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__interpenetrate()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__interpenetrate(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_INTERPENETRATE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__interpenetrate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIMITS = "limits";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__LIMITS = "technique_common__limits";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__limits( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__limits( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__limits()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__limits( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SWING_CONE_AND_TWIST = "swing_cone_and_twist";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIMITS__SWING_CONE_AND_TWIST = "limits__swing_cone_and_twist";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__swing_cone_and_twist( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MIN = "min";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SWING_CONE_AND_TWIST__MIN = "swing_cone_and_twist__min";

//---------------------------------------------------------------------
const min__AttributeData min__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist__min( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__swing_cone_and_twist__min);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
min__AttributeData* attributeData = newData<min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SWING_CONE_AND_TWIST__MIN, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist__min()
{
return doubleDataEnd( &ColladaParserAutoGen::data__swing_cone_and_twist__min );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__swing_cone_and_twist__min( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_MAX = "max";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SWING_CONE_AND_TWIST__MAX = "swing_cone_and_twist__max";

//---------------------------------------------------------------------
const max__AttributeData max__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist__max( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__swing_cone_and_twist__max);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
max__AttributeData* attributeData = newData<max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SWING_CONE_AND_TWIST__MAX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist__max()
{
return doubleDataEnd( &ColladaParserAutoGen::data__swing_cone_and_twist__max );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__swing_cone_and_twist__max( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR = "linear";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIMITS__LINEAR = "limits__linear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__limits__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__limits__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__limits__linear()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__limits__linear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR__MIN = "linear__min";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linear__min( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__min);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linear__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
min__AttributeData* attributeData = newData<min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR__MIN, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linear__min()
{
return doubleDataEnd( &ColladaParserAutoGen::data__linear__min );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linear__min( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR__MAX = "linear__max";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linear__max( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__max);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linear__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
max__AttributeData* attributeData = newData<max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR__MAX, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linear__max()
{
return doubleDataEnd( &ColladaParserAutoGen::data__linear__max );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linear__max( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPRING = "spring";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__SPRING = "technique_common__spring";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spring( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spring( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spring()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spring( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANGULAR = "angular";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPRING__ANGULAR = "spring__angular";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__angular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__angular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__angular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__angular( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_STIFFNESS = "stiffness";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANGULAR__STIFFNESS = "angular__stiffness";

//---------------------------------------------------------------------
const stiffness__AttributeData stiffness__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__angular__stiffness( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__angular__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stiffness__AttributeData* attributeData = newData<stiffness__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANGULAR__STIFFNESS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__angular__stiffness()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__angular__stiffness(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANGULAR__STIFFNESS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__angular__stiffness( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DAMPING = "damping";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANGULAR__DAMPING = "angular__damping";

//---------------------------------------------------------------------
const damping__AttributeData damping__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__angular__damping( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__angular__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
damping__AttributeData* attributeData = newData<damping__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANGULAR__DAMPING, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__angular__damping()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__angular__damping(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANGULAR__DAMPING, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__angular__damping( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TARGET_VALUE = "target_value";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANGULAR__TARGET_VALUE = "angular__target_value";

//---------------------------------------------------------------------
const target_value__AttributeData target_value__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__angular__target_value( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__angular__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
target_value__AttributeData* attributeData = newData<target_value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANGULAR__TARGET_VALUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__angular__target_value()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__angular__target_value(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANGULAR__TARGET_VALUE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__angular__target_value( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPRING__LINEAR = "spring__linear";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__spring__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__spring__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__spring__linear()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__spring__linear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR__STIFFNESS = "linear__stiffness";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linear__stiffness( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linear__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stiffness__AttributeData* attributeData = newData<stiffness__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR__STIFFNESS, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linear__stiffness()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__linear__stiffness(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LINEAR__STIFFNESS, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linear__stiffness( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR__DAMPING = "linear__damping";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linear__damping( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linear__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
damping__AttributeData* attributeData = newData<damping__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR__DAMPING, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linear__damping()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__linear__damping(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LINEAR__DAMPING, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linear__damping( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LINEAR__TARGET_VALUE = "linear__target_value";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__linear__target_value( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__linear__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
target_value__AttributeData* attributeData = newData<target_value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR__TARGET_VALUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__linear__target_value()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__linear__target_value(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LINEAR__TARGET_VALUE, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__linear__target_value( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE = "rigid_constraint__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_constraint__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_constraint__technique__AttributeData* attributeData = newData<rigid_constraint__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_constraint__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RIGID_CONSTRAINT__EXTRA = "rigid_constraint__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__rigid_constraint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_CONSTRAINT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__rigid_constraint__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL = "instance_physics_model";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL__INSTANCE_PHYSICS_MODEL = "physics_model__instance_physics_model";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_PARENT = "parent";

//---------------------------------------------------------------------
const instance_physics_model__AttributeData instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_model__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_model__AttributeData* attributeData = newData<instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {

attributeData->parent = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MODEL__INSTANCE_PHYSICS_MODEL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__instance_physics_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_model__instance_physics_model( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_FORCE_FIELD = "instance_force_field";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_FORCE_FIELD = "instance_physics_model__instance_force_field";

//---------------------------------------------------------------------
const instance_force_field__AttributeData instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_physics_model__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_model__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_force_field__AttributeData* attributeData = newData<instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_FORCE_FIELD, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_model__instance_force_field()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_physics_model__instance_force_field( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_FORCE_FIELD__EXTRA = "instance_force_field__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_force_field__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_FORCE_FIELD__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_force_field__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_force_field__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY = "instance_rigid_body";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_RIGID_BODY = "instance_physics_model__instance_rigid_body";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_BODY = "body";

//---------------------------------------------------------------------
const instance_rigid_body__AttributeData instance_rigid_body__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_body__AttributeData* attributeData = newData<instance_rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_BODY:
    {

attributeData->body = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_BODY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_body( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON = "instance_rigid_body__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_body__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ANGULAR_VELOCITY = "angular_velocity";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__ANGULAR_VELOCITY = "technique_common__angular_velocity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__angular_velocity( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__angular_velocity);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__angular_velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__angular_velocity()
{
return doubleDataEnd( &ColladaParserAutoGen::data__angular_velocity );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__angular_velocity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VELOCITY = "velocity";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__VELOCITY = "technique_common__velocity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__velocity( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__velocity);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__velocity()
{
return doubleDataEnd( &ColladaParserAutoGen::data__velocity );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__velocity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE = "instance_rigid_body__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_body__technique__AttributeData* attributeData = newData<instance_rigid_body__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_body__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__EXTRA = "instance_rigid_body__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_BODY__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_body__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_CONSTRAINT = "instance_rigid_constraint";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_RIGID_CONSTRAINT = "instance_physics_model__instance_rigid_constraint";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_CONSTRAINT = "constraint";

//---------------------------------------------------------------------
const instance_rigid_constraint__AttributeData instance_rigid_constraint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_constraint__AttributeData* attributeData = newData<instance_rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONSTRAINT:
    {

attributeData->constraint = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_constraint()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_constraint( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_RIGID_CONSTRAINT__EXTRA = "instance_rigid_constraint__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_rigid_constraint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_constraint__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_rigid_constraint__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__EXTRA = "instance_physics_model__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_physics_model__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_model__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_physics_model__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_MODEL__EXTRA = "physics_model__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_model__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MODEL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_model__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__EXTRA = "library_physics_models__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_models__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MODELS__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_models__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES = "library_physics_scenes";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_SCENES = "COLLADA__library_physics_scenes";

//---------------------------------------------------------------------
const library_physics_scenes__AttributeData library_physics_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_scenes__AttributeData* attributeData = newData<library_physics_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_SCENES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_scenes( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__ASSET = "library_physics_scenes__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_scenes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_scenes__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE = "physics_scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__PHYSICS_SCENE = "library_physics_scenes__physics_scene";

//---------------------------------------------------------------------
const physics_scene__AttributeData physics_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__AttributeData* attributeData = newData<physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__ASSET = "physics_scene__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__INSTANCE_FORCE_FIELD = "physics_scene__instance_force_field";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_force_field__AttributeData* attributeData = newData<instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_FORCE_FIELD, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__instance_force_field()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__instance_force_field( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__INSTANCE_PHYSICS_MODEL = "physics_scene__instance_physics_model";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_model__AttributeData* attributeData = newData<instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {

attributeData->parent = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_PHYSICS_MODEL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__instance_physics_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__instance_physics_model( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__TECHNIQUE_COMMON = "physics_scene__technique_common";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GRAVITY = "gravity";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__GRAVITY = "technique_common__gravity";

//---------------------------------------------------------------------
const gravity__AttributeData gravity__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__gravity( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__gravity);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__gravity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
gravity__AttributeData* attributeData = newData<gravity__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GRAVITY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__gravity()
{
return doubleDataEnd( &ColladaParserAutoGen::data__gravity );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__gravity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TIME_STEP = "time_step";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE_COMMON__TIME_STEP = "technique_common__time_step";

//---------------------------------------------------------------------
const time_step__AttributeData time_step__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__time_step( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__time_step( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
time_step__AttributeData* attributeData = newData<time_step__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TIME_STEP, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__time_step()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__time_step(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TIME_STEP, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__time_step( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__TECHNIQUE = "physics_scene__technique";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__technique__AttributeData* attributeData = newData<physics_scene__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHYSICS_SCENE__EXTRA = "physics_scene__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__physics_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__physics_scene__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__EXTRA = "library_physics_scenes__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_physics_scenes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_SCENES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_physics_scenes__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES = "library_visual_scenes";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__LIBRARY_VISUAL_SCENES = "COLLADA__library_visual_scenes";

//---------------------------------------------------------------------
const library_visual_scenes__AttributeData library_visual_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_visual_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_visual_scenes__AttributeData* attributeData = newData<library_visual_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_VISUAL_SCENES, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_visual_scenes( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__ASSET = "library_visual_scenes__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_visual_scenes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_visual_scenes__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VISUAL_SCENE = "visual_scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__VISUAL_SCENE = "library_visual_scenes__visual_scene";

//---------------------------------------------------------------------
const visual_scene__AttributeData visual_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
visual_scene__AttributeData* attributeData = newData<visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VISUAL_SCENE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__visual_scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VISUAL_SCENE__ASSET = "visual_scene__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__visual_scene__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__visual_scene__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VISUAL_SCENE__NODE = "visual_scene__node";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__visual_scene__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<NodeType, StringHash, NodeType__COUNT>(attributeValue, failed, NodeTypeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE__NODE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {

attributeData->layer = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VISUAL_SCENE__NODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__node()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__visual_scene__node( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EVALUATE_SCENE = "evaluate_scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VISUAL_SCENE__EVALUATE_SCENE = "visual_scene__evaluate_scene";

//---------------------------------------------------------------------
const evaluate_scene__AttributeData evaluate_scene__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__evaluate_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__evaluate_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
evaluate_scene__AttributeData* attributeData = newData<evaluate_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EVALUATE_SCENE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__evaluate_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__evaluate_scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RENDER = "render";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EVALUATE_SCENE__RENDER = "evaluate_scene__render";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_CAMERA_NODE = "camera_node";

//---------------------------------------------------------------------
const render__AttributeData render__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__render( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__render( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
render__AttributeData* attributeData = newData<render__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CAMERA_NODE:
    {

attributeData->camera_node = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RENDER, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__render()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__render( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAYER = "layer";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RENDER__LAYER = "render__layer";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__layer( const ParserChar* text, size_t textLength )
{
return mImpl->data__layer(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__layer( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__layer()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__layer( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_RENDER__INSTANCE_EFFECT = "render__instance_effect";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__render__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__render__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__AttributeData* attributeData = newData<instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RENDER__INSTANCE_EFFECT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__render__instance_effect()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__render__instance_effect( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_VISUAL_SCENE__EXTRA = "visual_scene__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__visual_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VISUAL_SCENE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__visual_scene__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__EXTRA = "library_visual_scenes__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__library_visual_scenes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_VISUAL_SCENES__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__library_visual_scenes__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCENE = "scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__SCENE = "COLLADA__scene";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_SCENE = "instance_physics_scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCENE__INSTANCE_PHYSICS_SCENE = "scene__instance_physics_scene";

//---------------------------------------------------------------------
const instance_physics_scene__AttributeData instance_physics_scene__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_scene__AttributeData* attributeData = newData<instance_physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_SCENE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_physics_scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_PHYSICS_SCENE__EXTRA = "instance_physics_scene__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_physics_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_SCENE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_physics_scene__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_VISUAL_SCENE = "instance_visual_scene";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCENE__INSTANCE_VISUAL_SCENE = "scene__instance_visual_scene";

//---------------------------------------------------------------------
const instance_visual_scene__AttributeData instance_visual_scene__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_visual_scene__AttributeData* attributeData = newData<instance_visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_VISUAL_SCENE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_visual_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_visual_scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INSTANCE_VISUAL_SCENE__EXTRA = "instance_visual_scene__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__instance_visual_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__instance_visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_VISUAL_SCENE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__instance_visual_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__instance_visual_scene__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SCENE__EXTRA = "scene__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCENE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__scene__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_COLLADA__EXTRA = "COLLADA__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__COLLADA__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLLADA__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__COLLADA__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL = "profile_GLSL";

//---------------------------------------------------------------------
const profile_GLSL__AttributeData profile_GLSL__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__AttributeData* attributeData = newData<profile_GLSL__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__ASSET = "profile_GLSL__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CODE = "code";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__CODE = "profile_GLSL__code";

//---------------------------------------------------------------------
const code__AttributeData code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__code( const ParserChar* text, size_t textLength )
{
return mImpl->data__profile_GLSL__code(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
code__AttributeData* attributeData = newData<code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__CODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__code()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__code( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INCLUDE = "include";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__INCLUDE = "profile_GLSL__include";

//---------------------------------------------------------------------
const include__AttributeData include__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
include__AttributeData* attributeData = newData<include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__INCLUDE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__include()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__include( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__IMAGE = "profile_GLSL__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__NEWPARAM = "profile_GLSL__newparam";

//---------------------------------------------------------------------
const profile_GLSL__newparam__AttributeData profile_GLSL__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__newparam__AttributeData* attributeData = newData<profile_GLSL__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY = "array";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__ARRAY = "newparam__array";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_LENGTH = "length";

//---------------------------------------------------------------------
const newparam__array__AttributeData newparam__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__array__AttributeData* attributeData = newData<newparam__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL = "array__bool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__bool(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__BOOL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL2 = "array__bool2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL3 = "array__bool3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL4 = "array__bool4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT = "array__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT2 = "array__float2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT3 = "array__float3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT4 = "array__float4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT2X2 = "array__float2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT3X3 = "array__float3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT4X4 = "array__float4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT = "array__int";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__int(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__INT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT2 = "array__int2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int2()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT3 = "array__int3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int3()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT4 = "array__int4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int4()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SURFACE = "array__surface";

//---------------------------------------------------------------------
const array__surface__AttributeData array__surface__AttributeData::DEFAULT = {fx_surface_type_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
array__surface__AttributeData* attributeData = newData<array__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(attributeValue, failed, fx_surface_type_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__SURFACE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY__SURFACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR = "generator";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SURFACE__GENERATOR = "surface__generator";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR__ANNOTATE = "generator__annotate";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GENERATOR__ANNOTATE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator__annotate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR__CODE = "generator__code";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator__code( const ParserChar* text, size_t textLength )
{
return mImpl->data__generator__code(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
code__AttributeData* attributeData = newData<code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GENERATOR__CODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator__code()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator__code( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR__INCLUDE = "generator__include";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
include__AttributeData* attributeData = newData<include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GENERATOR__INCLUDE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator__include()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator__include( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NAME = "name";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR__NAME = "generator__name";

//---------------------------------------------------------------------
const generator__name__AttributeData generator__name__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator__name( const ParserChar* text, size_t textLength )
{
return mImpl->data__generator__name(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator__name( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__name__AttributeData* attributeData = newData<generator__name__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GENERATOR__NAME, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator__name()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator__name( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_GENERATOR__SETPARAM = "generator__setparam";

//---------------------------------------------------------------------
const generator__setparam__AttributeData generator__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__generator__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__generator__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__setparam__AttributeData* attributeData = newData<generator__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GENERATOR__SETPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__generator__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__generator__setparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLER1D = "array__sampler1D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__sampler1D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLER2D = "array__sampler2D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__sampler2D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLER3D = "array__sampler3D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__sampler3D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLERCUBE = "array__samplerCUBE";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__samplerCUBE( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLERRECT = "array__samplerRECT";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__samplerRECT( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__SAMPLERDEPTH = "array__samplerDEPTH";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__samplerDEPTH( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__ENUM = "array__enum";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__enum( const ParserChar* text, size_t textLength )
{
return mImpl->data__array__enum(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__enum()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__ARRAY = "array__array";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
array__array__AttributeData* attributeData = newData<array__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY__ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE = "profile_GLSL__technique";

//---------------------------------------------------------------------
const profile_GLSL__technique__AttributeData profile_GLSL__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__technique__AttributeData* attributeData = newData<profile_GLSL__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__CODE = "technique__code";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__code( const ParserChar* text, size_t textLength )
{
return mImpl->data__technique__code(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
code__AttributeData* attributeData = newData<code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__CODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__code()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__code( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__INCLUDE = "technique__include";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
include__AttributeData* attributeData = newData<include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE__INCLUDE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__include()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__include( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_GLSL__EXTRA = "profile_GLSL__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_GLSL__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_GLSL__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG = "profile_CG";

//---------------------------------------------------------------------
const profile_CG__AttributeData profile_CG__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__AttributeData* attributeData = newData<profile_CG__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__ASSET = "profile_CG__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__CODE = "profile_CG__code";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__code( const ParserChar* text, size_t textLength )
{
return mImpl->data__profile_CG__code(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
code__AttributeData* attributeData = newData<code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__CODE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__code()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__code( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__INCLUDE = "profile_CG__include";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
include__AttributeData* attributeData = newData<include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__INCLUDE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__include()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__include( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__IMAGE = "profile_CG__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__NEWPARAM = "profile_CG__newparam";

//---------------------------------------------------------------------
const profile_CG__newparam__AttributeData profile_CG__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__newparam__AttributeData* attributeData = newData<profile_CG__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL1 = "bool1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL1 = "newparam__bool1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__bool1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__BOOL1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL1X1 = "bool1x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL1X1 = "newparam__bool1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool1x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL1X2 = "bool1x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL1X2 = "newparam__bool1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool1x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL1X3 = "bool1x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL1X3 = "newparam__bool1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool1x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL1X4 = "bool1x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL1X4 = "newparam__bool1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool1x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL2X1 = "bool2x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL2X1 = "newparam__bool2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool2x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL2X2 = "bool2x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL2X2 = "newparam__bool2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool2x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL2X3 = "bool2x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL2X3 = "newparam__bool2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool2x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL2X4 = "bool2x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL2X4 = "newparam__bool2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool2x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL3X1 = "bool3x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL3X1 = "newparam__bool3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool3x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL3X2 = "bool3x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL3X2 = "newparam__bool3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool3x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL3X3 = "bool3x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL3X3 = "newparam__bool3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool3x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL3X4 = "bool3x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL3X4 = "newparam__bool3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool3x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL4X1 = "bool4x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL4X1 = "newparam__bool4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool4x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL4X2 = "bool4x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL4X2 = "newparam__bool4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool4x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL4X3 = "bool4x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL4X3 = "newparam__bool4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool4x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BOOL4X4 = "bool4x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__BOOL4X4 = "newparam__bool4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__bool4x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__newparam__bool4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__bool4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FLOAT1 = "float1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FLOAT1 = "newparam__float1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__float1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__float1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__FLOAT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__float1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT1 = "int1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT1 = "newparam__int1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__int1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__INT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT1X1 = "int1x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT1X1 = "newparam__int1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int1x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x1()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT1X2 = "int1x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT1X2 = "newparam__int1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int1x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x2()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT1X3 = "int1x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT1X3 = "newparam__int1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int1x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x3()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT1X4 = "int1x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT1X4 = "newparam__int1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int1x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x4()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT2X1 = "int2x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT2X1 = "newparam__int2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int2x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x1()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT2X2 = "int2x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT2X2 = "newparam__int2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int2x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x2()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT2X3 = "int2x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT2X3 = "newparam__int2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int2x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x3()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT2X4 = "int2x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT2X4 = "newparam__int2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int2x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x4()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT3X1 = "int3x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT3X1 = "newparam__int3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int3x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x1()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT3X2 = "int3x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT3X2 = "newparam__int3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int3x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x2()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT3X3 = "int3x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT3X3 = "newparam__int3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int3x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x3()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT3X4 = "int3x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT3X4 = "newparam__int3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int3x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x4()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT4X1 = "int4x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT4X1 = "newparam__int4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int4x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x1()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT4X2 = "int4x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT4X2 = "newparam__int4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int4x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x2()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT4X3 = "int4x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT4X3 = "newparam__int4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int4x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x3()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INT4X4 = "int4x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__INT4X4 = "newparam__int4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__int4x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x4()
{
return longDataEnd( &ColladaParserAutoGen::data__newparam__int4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__int4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF = "half";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF = "newparam__half";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__half(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__HALF, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF1 = "half1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF1 = "newparam__half1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__half1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__HALF1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF2 = "half2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF2 = "newparam__half2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF3 = "half3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF3 = "newparam__half3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF4 = "half4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF4 = "newparam__half4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF1X1 = "half1x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF1X1 = "newparam__half1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF1X2 = "half1x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF1X2 = "newparam__half1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF1X3 = "half1x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF1X3 = "newparam__half1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF1X4 = "half1x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF1X4 = "newparam__half1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF2X1 = "half2x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF2X1 = "newparam__half2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF2X2 = "half2x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF2X2 = "newparam__half2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF2X3 = "half2x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF2X3 = "newparam__half2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF2X4 = "half2x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF2X4 = "newparam__half2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF3X1 = "half3x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF3X1 = "newparam__half3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF3X2 = "half3x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF3X2 = "newparam__half3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF3X3 = "half3x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF3X3 = "newparam__half3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF3X4 = "half3x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF3X4 = "newparam__half3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF4X1 = "half4x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF4X1 = "newparam__half4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF4X2 = "half4x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF4X2 = "newparam__half4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF4X3 = "half4x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF4X3 = "newparam__half4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_HALF4X4 = "half4x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__HALF4X4 = "newparam__half4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__half4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__half4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__half4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED = "fixed";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED = "newparam__fixed";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__fixed(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__FIXED, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED1 = "fixed1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED1 = "newparam__fixed1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__newparam__fixed1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_NEWPARAM__FIXED1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED2 = "fixed2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED2 = "newparam__fixed2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED3 = "fixed3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED3 = "newparam__fixed3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED4 = "fixed4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED4 = "newparam__fixed4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED1X1 = "fixed1x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED1X1 = "newparam__fixed1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED1X2 = "fixed1x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED1X2 = "newparam__fixed1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED1X3 = "fixed1x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED1X3 = "newparam__fixed1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED1X4 = "fixed1x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED1X4 = "newparam__fixed1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED2X1 = "fixed2x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED2X1 = "newparam__fixed2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED2X2 = "fixed2x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED2X2 = "newparam__fixed2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED2X3 = "fixed2x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED2X3 = "newparam__fixed2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED2X4 = "fixed2x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED2X4 = "newparam__fixed2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED3X1 = "fixed3x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED3X1 = "newparam__fixed3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED3X2 = "fixed3x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED3X2 = "newparam__fixed3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED3X3 = "fixed3x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED3X3 = "newparam__fixed3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED3X4 = "fixed3x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED3X4 = "newparam__fixed3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED4X1 = "fixed4x1";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED4X1 = "newparam__fixed4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED4X2 = "fixed4x2";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED4X2 = "newparam__fixed4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED4X3 = "fixed4x3";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED4X3 = "newparam__fixed4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_FIXED4X4 = "fixed4x4";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__FIXED4X4 = "newparam__fixed4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__newparam__fixed4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__fixed4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__STRING = "newparam__string";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__string( const ParserChar* text, size_t textLength )
{
return mImpl->data__newparam__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE = "usertype";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_NEWPARAM__USERTYPE = "newparam__usertype";

//---------------------------------------------------------------------
const usertype__AttributeData usertype__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__newparam__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__newparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__AttributeData* attributeData = newData<usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM__USERTYPE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__newparam__usertype()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__newparam__usertype( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL = "usertype__bool";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__bool(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__BOOL, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL1 = "usertype__bool1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__bool1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__BOOL1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL2 = "usertype__bool2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL3 = "usertype__bool3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL4 = "usertype__bool4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL1X1 = "usertype__bool1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool1x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL1X2 = "usertype__bool1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool1x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL1X3 = "usertype__bool1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool1x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL1X4 = "usertype__bool1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool1x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL2X1 = "usertype__bool2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool2x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL2X2 = "usertype__bool2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool2x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL2X3 = "usertype__bool2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool2x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL2X4 = "usertype__bool2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool2x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL3X1 = "usertype__bool3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool3x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL3X2 = "usertype__bool3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool3x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL3X3 = "usertype__bool3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool3x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL3X4 = "usertype__bool3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool3x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL4X1 = "usertype__bool4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool4x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL4X2 = "usertype__bool4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool4x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL4X3 = "usertype__bool4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool4x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__BOOL4X4 = "usertype__bool4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__bool4x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__usertype__bool4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__bool4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT = "usertype__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT1 = "usertype__float1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__float1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__FLOAT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT2 = "usertype__float2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT3 = "usertype__float3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT4 = "usertype__float4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT1X1 = "usertype__float1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT1X2 = "usertype__float1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT1X3 = "usertype__float1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT1X4 = "usertype__float1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT2X1 = "usertype__float2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT2X2 = "usertype__float2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT2X3 = "usertype__float2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT2X4 = "usertype__float2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT3X1 = "usertype__float3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT3X2 = "usertype__float3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT3X3 = "usertype__float3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT3X4 = "usertype__float3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT4X1 = "usertype__float4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT4X2 = "usertype__float4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT4X3 = "usertype__float4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FLOAT4X4 = "usertype__float4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__float4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__float4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT = "usertype__int";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__int(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__INT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT1 = "usertype__int1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__int1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__INT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT2 = "usertype__int2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT3 = "usertype__int3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT4 = "usertype__int4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT1X1 = "usertype__int1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int1x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x1()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT1X2 = "usertype__int1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int1x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x2()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT1X3 = "usertype__int1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int1x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x3()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT1X4 = "usertype__int1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int1x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x4()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT2X1 = "usertype__int2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int2x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x1()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT2X2 = "usertype__int2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int2x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x2()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT2X3 = "usertype__int2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int2x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x3()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT2X4 = "usertype__int2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int2x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x4()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT3X1 = "usertype__int3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int3x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x1()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT3X2 = "usertype__int3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int3x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x2()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT3X3 = "usertype__int3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int3x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x3()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT3X4 = "usertype__int3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int3x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x4()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT4X1 = "usertype__int4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int4x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x1()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT4X2 = "usertype__int4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int4x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x2()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT4X3 = "usertype__int4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int4x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x3()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__INT4X4 = "usertype__int4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__int4x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x4()
{
return longDataEnd( &ColladaParserAutoGen::data__usertype__int4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__int4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF = "usertype__half";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__half(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__HALF, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF1 = "usertype__half1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__half1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__HALF1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF2 = "usertype__half2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF3 = "usertype__half3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF4 = "usertype__half4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF1X1 = "usertype__half1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF1X2 = "usertype__half1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF1X3 = "usertype__half1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF1X4 = "usertype__half1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF2X1 = "usertype__half2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF2X2 = "usertype__half2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF2X3 = "usertype__half2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF2X4 = "usertype__half2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF3X1 = "usertype__half3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF3X2 = "usertype__half3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF3X3 = "usertype__half3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF3X4 = "usertype__half3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF4X1 = "usertype__half4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF4X2 = "usertype__half4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF4X3 = "usertype__half4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__HALF4X4 = "usertype__half4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__half4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__half4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__half4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED = "usertype__fixed";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__fixed(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__FIXED, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED1 = "usertype__fixed1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__usertype__fixed1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_USERTYPE__FIXED1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED2 = "usertype__fixed2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED3 = "usertype__fixed3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED4 = "usertype__fixed4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED1X1 = "usertype__fixed1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED1X2 = "usertype__fixed1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED1X3 = "usertype__fixed1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED1X4 = "usertype__fixed1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED2X1 = "usertype__fixed2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED2X2 = "usertype__fixed2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED2X3 = "usertype__fixed2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED2X4 = "usertype__fixed2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED3X1 = "usertype__fixed3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED3X2 = "usertype__fixed3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED3X3 = "usertype__fixed3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED3X4 = "usertype__fixed3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED4X1 = "usertype__fixed4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED4X2 = "usertype__fixed4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED4X3 = "usertype__fixed4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__FIXED4X4 = "usertype__fixed4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__usertype__fixed4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__fixed4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SURFACE = "usertype__surface";

//---------------------------------------------------------------------
const usertype__surface__AttributeData usertype__surface__AttributeData::DEFAULT = {fx_surface_type_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__surface__AttributeData* attributeData = newData<usertype__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<fx_surface_type_enum, StringHash, fx_surface_type_enum__COUNT>(attributeValue, failed, fx_surface_type_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__SURFACE, HASH_ATTRIBUTE_TYPE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE__SURFACE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLER1D = "usertype__sampler1D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__sampler1D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLER2D = "usertype__sampler2D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__sampler2D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLER3D = "usertype__sampler3D";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__sampler3D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLERRECT = "usertype__samplerRECT";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__samplerRECT( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLERCUBE = "usertype__samplerCUBE";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__samplerCUBE( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SAMPLERDEPTH = "usertype__samplerDEPTH";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__samplerDEPTH( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__STRING = "usertype__string";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__string( const ParserChar* text, size_t textLength )
{
return mImpl->data__usertype__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__ENUM = "usertype__enum";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__enum( const ParserChar* text, size_t textLength )
{
return mImpl->data__usertype__enum(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__enum()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__ARRAY = "usertype__array";

//---------------------------------------------------------------------
const usertype__array__AttributeData usertype__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__array__AttributeData* attributeData = newData<usertype__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE__ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL1 = "array__bool1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__bool1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__BOOL1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL1X1 = "array__bool1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool1x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL1X2 = "array__bool1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool1x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL1X3 = "array__bool1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool1x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL1X4 = "array__bool1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool1x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL2X1 = "array__bool2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool2x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL2X2 = "array__bool2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool2x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL2X3 = "array__bool2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool2x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL2X4 = "array__bool2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool2x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL3X1 = "array__bool3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool3x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL3X2 = "array__bool3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool3x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL3X3 = "array__bool3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool3x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL3X4 = "array__bool3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool3x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL4X1 = "array__bool4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool4x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL4X2 = "array__bool4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool4x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL4X3 = "array__bool4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool4x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__BOOL4X4 = "array__bool4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__bool4x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__array__bool4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__bool4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT1 = "array__float1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__float1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__FLOAT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT1X1 = "array__float1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT1X2 = "array__float1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT1X3 = "array__float1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT1X4 = "array__float1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT2X1 = "array__float2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT2X3 = "array__float2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT2X4 = "array__float2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT3X1 = "array__float3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT3X2 = "array__float3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT3X4 = "array__float3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT4X1 = "array__float4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT4X2 = "array__float4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FLOAT4X3 = "array__float4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__float4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__float4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__float4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__float4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT1 = "array__int1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int1()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__int1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__INT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT1X1 = "array__int1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int1x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x1()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT1X2 = "array__int1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int1x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x2()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT1X3 = "array__int1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int1x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x3()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT1X4 = "array__int1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int1x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x4()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT2X1 = "array__int2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int2x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x1()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT2X2 = "array__int2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int2x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x2()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT2X3 = "array__int2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int2x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x3()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT2X4 = "array__int2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int2x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x4()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT3X1 = "array__int3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int3x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x1()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT3X2 = "array__int3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int3x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x2()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT3X3 = "array__int3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int3x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x3()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT3X4 = "array__int3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int3x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x4()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT4X1 = "array__int4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int4x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x1()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT4X2 = "array__int4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int4x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x2()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT4X3 = "array__int4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int4x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x3()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__INT4X4 = "array__int4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__int4x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__array__int4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x4()
{
return longDataEnd( &ColladaParserAutoGen::data__array__int4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__int4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF = "array__half";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__half(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__HALF, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF1 = "array__half1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__half1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__HALF1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF2 = "array__half2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF3 = "array__half3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF4 = "array__half4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF1X1 = "array__half1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF1X2 = "array__half1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF1X3 = "array__half1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF1X4 = "array__half1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF2X1 = "array__half2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF2X2 = "array__half2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF2X3 = "array__half2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF2X4 = "array__half2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF3X1 = "array__half3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF3X2 = "array__half3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF3X3 = "array__half3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF3X4 = "array__half3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF4X1 = "array__half4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF4X2 = "array__half4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF4X3 = "array__half4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__HALF4X4 = "array__half4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__half4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__half4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__half4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__half4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED = "array__fixed";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__fixed(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__FIXED, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED1 = "array__fixed1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__array__fixed1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ARRAY__FIXED1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED2 = "array__fixed2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED3 = "array__fixed3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED4 = "array__fixed4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED1X1 = "array__fixed1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED1X2 = "array__fixed1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED1X3 = "array__fixed1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED1X4 = "array__fixed1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED2X1 = "array__fixed2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED2X2 = "array__fixed2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED2X3 = "array__fixed2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED2X4 = "array__fixed2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED3X1 = "array__fixed3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED3X2 = "array__fixed3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED3X3 = "array__fixed3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED3X4 = "array__fixed3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED4X1 = "array__fixed4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED4X2 = "array__fixed4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED4X3 = "array__fixed4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__FIXED4X4 = "array__fixed4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__fixed4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__array__fixed4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__fixed4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__STRING = "array__string";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__string( const ParserChar* text, size_t textLength )
{
return mImpl->data__array__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_ARRAY__USERTYPE = "array__usertype";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__array__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__array__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__AttributeData* attributeData = newData<usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY__USERTYPE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__array__usertype()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__array__usertype( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__USERTYPE = "usertype__usertype";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__AttributeData* attributeData = newData<usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE__USERTYPE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__usertype()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__usertype( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONNECT_PARAM = "connect_param";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__CONNECT_PARAM = "usertype__connect_param";

//---------------------------------------------------------------------
const connect_param__AttributeData connect_param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__connect_param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
connect_param__AttributeData* attributeData = newData<connect_param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE__CONNECT_PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__connect_param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__connect_param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_USERTYPE__SETPARAM = "usertype__setparam";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_PROGRAM = "program";

//---------------------------------------------------------------------
const usertype__setparam__AttributeData usertype__setparam__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__usertype__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__usertype__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__setparam__AttributeData* attributeData = newData<usertype__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PROGRAM:
    {

attributeData->program = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE__SETPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__usertype__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__usertype__setparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL1 = "setparam__bool1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1()
{
bool failed;
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__bool1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__BOOL1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL1X1 = "setparam__bool1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool1x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL1X2 = "setparam__bool1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool1x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL1X3 = "setparam__bool1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool1x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL1X4 = "setparam__bool1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool1x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL2X1 = "setparam__bool2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool2x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL2X2 = "setparam__bool2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool2x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL2X3 = "setparam__bool2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool2x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL2X4 = "setparam__bool2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool2x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL3X1 = "setparam__bool3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool3x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL3X2 = "setparam__bool3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool3x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL3X3 = "setparam__bool3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool3x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL3X4 = "setparam__bool3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool3x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL4X1 = "setparam__bool4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool4x1( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x1()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL4X2 = "setparam__bool4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool4x2( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x2()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL4X3 = "setparam__bool4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool4x3( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x3()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__BOOL4X4 = "setparam__bool4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__bool4x4( const ParserChar* text, size_t textLength )
{
return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x4()
{
return boolDataEnd( &ColladaParserAutoGen::data__setparam__bool4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__bool4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FLOAT1 = "setparam__float1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__float1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__float1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__FLOAT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__float1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT1 = "setparam__int1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1()
{
bool failed;
long parameter = GeneratedSaxParser::Utils::toLong((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__int1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__INT1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT1X1 = "setparam__int1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int1x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x1()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT1X2 = "setparam__int1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int1x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x2()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT1X3 = "setparam__int1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int1x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x3()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT1X4 = "setparam__int1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int1x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x4()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT2X1 = "setparam__int2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int2x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x1()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT2X2 = "setparam__int2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int2x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x2()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT2X3 = "setparam__int2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int2x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x3()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT2X4 = "setparam__int2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int2x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x4()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT3X1 = "setparam__int3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int3x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x1()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT3X2 = "setparam__int3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int3x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x2()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT3X3 = "setparam__int3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int3x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x3()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT3X4 = "setparam__int3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int3x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x4()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT4X1 = "setparam__int4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int4x1( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x1()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT4X2 = "setparam__int4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int4x2( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x2()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT4X3 = "setparam__int4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int4x3( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x3()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__INT4X4 = "setparam__int4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__int4x4( const ParserChar* text, size_t textLength )
{
return characterData2LongData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x4()
{
return longDataEnd( &ColladaParserAutoGen::data__setparam__int4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__int4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF = "setparam__half";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__half(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__HALF, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF1 = "setparam__half1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__half1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__HALF1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF2 = "setparam__half2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF3 = "setparam__half3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF4 = "setparam__half4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF1X1 = "setparam__half1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF1X2 = "setparam__half1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF1X3 = "setparam__half1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF1X4 = "setparam__half1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF2X1 = "setparam__half2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF2X2 = "setparam__half2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF2X3 = "setparam__half2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF2X4 = "setparam__half2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF3X1 = "setparam__half3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF3X2 = "setparam__half3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF3X3 = "setparam__half3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF3X4 = "setparam__half3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF4X1 = "setparam__half4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF4X2 = "setparam__half4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF4X3 = "setparam__half4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__HALF4X4 = "setparam__half4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__half4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__half4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__half4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED = "setparam__fixed";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__fixed(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__FIXED, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED1 = "setparam__fixed1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__setparam__fixed1(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SETPARAM__FIXED1, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED2 = "setparam__fixed2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED3 = "setparam__fixed3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED4 = "setparam__fixed4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED1X1 = "setparam__fixed1x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed1x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED1X2 = "setparam__fixed1x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed1x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED1X3 = "setparam__fixed1x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed1x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED1X4 = "setparam__fixed1x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed1x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED2X1 = "setparam__fixed2x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed2x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED2X2 = "setparam__fixed2x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed2x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED2X3 = "setparam__fixed2x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed2x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED2X4 = "setparam__fixed2x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed2x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED3X1 = "setparam__fixed3x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed3x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED3X2 = "setparam__fixed3x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed3x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED3X3 = "setparam__fixed3x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed3x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED3X4 = "setparam__fixed3x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed3x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED4X1 = "setparam__fixed4x1";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x1( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x1);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x1()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed4x1 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED4X2 = "setparam__fixed4x2";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x2( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x2);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x2()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed4x2 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED4X3 = "setparam__fixed4x3";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x3( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x3);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x3()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed4x3 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__FIXED4X4 = "setparam__fixed4x4";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x4( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x4);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x4()
{
return doubleDataEnd( &ColladaParserAutoGen::data__setparam__fixed4x4 );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__fixed4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__STRING = "setparam__string";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__string( const ParserChar* text, size_t textLength )
{
return mImpl->data__setparam__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__USERTYPE = "setparam__usertype";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__AttributeData* attributeData = newData<usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__USERTYPE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__usertype()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__usertype( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__ARRAY = "setparam__array";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__array__AttributeData* attributeData = newData<setparam__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__ARRAY, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__array( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SETPARAM__CONNECT_PARAM = "setparam__connect_param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__setparam__connect_param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__setparam__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
connect_param__AttributeData* attributeData = newData<connect_param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM__CONNECT_PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__setparam__connect_param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__setparam__connect_param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE = "profile_CG__technique";

//---------------------------------------------------------------------
const profile_CG__technique__AttributeData profile_CG__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__technique__AttributeData* attributeData = newData<profile_CG__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_CG__EXTRA = "profile_CG__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_CG__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_CG__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON = "profile_COMMON";

//---------------------------------------------------------------------
const profile_COMMON__AttributeData profile_COMMON__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__AttributeData* attributeData = newData<profile_COMMON__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON__ASSET = "profile_COMMON__asset";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON__IMAGE = "profile_COMMON__image";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__IMAGE, HASH_ATTRIBUTE_HEIGHT, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__IMAGE, HASH_ATTRIBUTE_WIDTH, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUnsignedLongLong(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__IMAGE, HASH_ATTRIBUTE_DEPTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON__IMAGE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON__image( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON__NEWPARAM = "profile_COMMON__newparam";

//---------------------------------------------------------------------
const profile_COMMON__newparam__AttributeData profile_COMMON__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__newparam__AttributeData* attributeData = newData<profile_COMMON__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON__NEWPARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON__newparam( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON__TECHNIQUE = "profile_COMMON__technique";

//---------------------------------------------------------------------
const profile_COMMON__technique__AttributeData profile_COMMON__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__technique__AttributeData* attributeData = newData<profile_COMMON__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON__TECHNIQUE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON__technique( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__CONSTANT = "technique__constant";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__technique__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__technique__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__technique__constant()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__technique__constant( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EMISSION = "emission";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__EMISSION = "constant__emission";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__emission( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EMISSION__COLOR = "emission__color";

//---------------------------------------------------------------------
const emission__color__AttributeData emission__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__emission__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__emission__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__emission__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
emission__color__AttributeData* attributeData = newData<emission__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EMISSION__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__emission__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__emission__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__emission__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EMISSION__PARAM = "emission__param";

//---------------------------------------------------------------------
const emission__param__AttributeData emission__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__emission__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__emission__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
emission__param__AttributeData* attributeData = newData<emission__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EMISSION__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__emission__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__emission__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE = "texture";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_EMISSION__TEXTURE = "emission__texture";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_TEXTURE = "texture";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_TEXCOORD = "texcoord";

//---------------------------------------------------------------------
const texture__AttributeData texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__emission__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__emission__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EMISSION__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__emission__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__emission__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TEXTURE__EXTRA = "texture__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__texture__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__texture__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__texture__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__texture__extra( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVE = "reflective";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__REFLECTIVE = "constant__reflective";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__reflective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVE__COLOR = "reflective__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__reflective__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__reflective__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__reflective__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflective__color__AttributeData* attributeData = newData<reflective__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REFLECTIVE__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__reflective__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__reflective__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__reflective__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVE__PARAM = "reflective__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__reflective__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__reflective__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflective__param__AttributeData* attributeData = newData<reflective__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REFLECTIVE__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__reflective__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__reflective__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVE__TEXTURE = "reflective__texture";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__reflective__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__reflective__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REFLECTIVE__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__reflective__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__reflective__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVITY = "reflectivity";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__REFLECTIVITY = "constant__reflectivity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__reflectivity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVITY__FLOAT = "reflectivity__float";

//---------------------------------------------------------------------
const reflectivity__float__AttributeData reflectivity__float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__reflectivity__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__reflectivity__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflectivity__float__AttributeData* attributeData = newData<reflectivity__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REFLECTIVITY__FLOAT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__reflectivity__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__reflectivity__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_REFLECTIVITY__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__reflectivity__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_REFLECTIVITY__PARAM = "reflectivity__param";

//---------------------------------------------------------------------
const reflectivity__param__AttributeData reflectivity__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__reflectivity__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__reflectivity__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflectivity__param__AttributeData* attributeData = newData<reflectivity__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REFLECTIVITY__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__reflectivity__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__reflectivity__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENT = "transparent";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__TRANSPARENT = "constant__transparent";

//---------------------------------------------------------------------
const char* NAME_ATTRIBUTE_OPAQUE = "opaque";

//---------------------------------------------------------------------
const transparent__AttributeData transparent__AttributeData::DEFAULT = {fx_opaque_enum__A_ONE};

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__AttributeData* attributeData = newData<transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {
bool failed;
attributeData->opaque = Utils::toEnum<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(attributeValue, failed, fx_opaque_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONSTANT__TRANSPARENT, HASH_ATTRIBUTE_OPAQUE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONSTANT__TRANSPARENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__transparent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
fx_opaque_enum ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_opaque_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, fx_opaque_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT, &toEnum_fx_opaque_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::characterData2EnumData_fx_opaque_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_opaque_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(text, textLength, dataFunction, fx_opaque_enumMap, baseConversionFunc, &toEnum_fx_opaque_enum, &ColladaParserAutoGenPrivate::toEnumDataPrefix_fx_opaque_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::dataEnumEnd_fx_opaque_enum (
    bool ( ColladaParserAutoGen::*dataFunction )(const fx_opaque_enum*, size_t ),
    const std::pair<StringHash, fx_opaque_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    fx_opaque_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, fx_opaque_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENT__COLOR = "transparent__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__transparent__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__transparent__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__transparent__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__color__AttributeData* attributeData = newData<transparent__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENT__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__transparent__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__transparent__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__transparent__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENT__PARAM = "transparent__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__transparent__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__transparent__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__param__AttributeData* attributeData = newData<transparent__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENT__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__transparent__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__transparent__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENT__TEXTURE = "transparent__texture";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__transparent__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__transparent__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENT__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__transparent__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__transparent__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENCY = "transparency";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__TRANSPARENCY = "constant__transparency";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__transparency( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENCY__FLOAT = "transparency__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__transparency__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__transparency__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparency__float__AttributeData* attributeData = newData<transparency__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENCY__FLOAT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__transparency__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__transparency__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TRANSPARENCY__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__transparency__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TRANSPARENCY__PARAM = "transparency__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__transparency__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__transparency__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparency__param__AttributeData* attributeData = newData<transparency__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENCY__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__transparency__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__transparency__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INDEX_OF_REFRACTION = "index_of_refraction";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_CONSTANT__INDEX_OF_REFRACTION = "constant__index_of_refraction";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__constant__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__constant__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__constant__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__constant__index_of_refraction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INDEX_OF_REFRACTION__FLOAT = "index_of_refraction__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__index_of_refraction__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__index_of_refraction__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
index_of_refraction__float__AttributeData* attributeData = newData<index_of_refraction__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INDEX_OF_REFRACTION__FLOAT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__index_of_refraction__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__index_of_refraction__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_INDEX_OF_REFRACTION__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__index_of_refraction__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_INDEX_OF_REFRACTION__PARAM = "index_of_refraction__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__index_of_refraction__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__index_of_refraction__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
index_of_refraction__param__AttributeData* attributeData = newData<index_of_refraction__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INDEX_OF_REFRACTION__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__index_of_refraction__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__index_of_refraction__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT = "lambert";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__LAMBERT = "technique__lambert";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__EMISSION = "lambert__emission";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__emission( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__AMBIENT = "lambert__ambient";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__ambient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AMBIENT__PARAM = "ambient__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ambient__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ambient__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ambient__param__AttributeData* attributeData = newData<ambient__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AMBIENT__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ambient__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ambient__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_AMBIENT__TEXTURE = "ambient__texture";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__ambient__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__ambient__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AMBIENT__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__ambient__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__ambient__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIFFUSE = "diffuse";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__DIFFUSE = "lambert__diffuse";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__diffuse( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIFFUSE__COLOR = "diffuse__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__diffuse__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__diffuse__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
diffuse__color__AttributeData* attributeData = newData<diffuse__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DIFFUSE__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__diffuse__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__diffuse__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIFFUSE__PARAM = "diffuse__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__diffuse__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
diffuse__param__AttributeData* attributeData = newData<diffuse__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DIFFUSE__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__diffuse__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_DIFFUSE__TEXTURE = "diffuse__texture";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__diffuse__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DIFFUSE__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__diffuse__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__REFLECTIVE = "lambert__reflective";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__reflective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__REFLECTIVITY = "lambert__reflectivity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__reflectivity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__TRANSPARENT = "lambert__transparent";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__AttributeData* attributeData = newData<transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {
bool failed;
attributeData->opaque = Utils::toEnum<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(attributeValue, failed, fx_opaque_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LAMBERT__TRANSPARENT, HASH_ATTRIBUTE_OPAQUE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LAMBERT__TRANSPARENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__transparent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__TRANSPARENCY = "lambert__transparency";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__transparency( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_LAMBERT__INDEX_OF_REFRACTION = "lambert__index_of_refraction";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__lambert__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__lambert__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__lambert__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__lambert__index_of_refraction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG = "phong";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__PHONG = "technique__phong";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__EMISSION = "phong__emission";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__emission( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__AMBIENT = "phong__ambient";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__ambient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__DIFFUSE = "phong__diffuse";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__diffuse( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPECULAR = "specular";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__SPECULAR = "phong__specular";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__specular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__specular( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPECULAR__COLOR = "specular__color";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__specular__color( const ParserChar* text, size_t textLength )
{
return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__specular__color);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__specular__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
specular__color__AttributeData* attributeData = newData<specular__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPECULAR__COLOR, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__specular__color()
{
return doubleDataEnd( &ColladaParserAutoGen::data__specular__color );
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__specular__color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPECULAR__PARAM = "specular__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__specular__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__specular__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
specular__param__AttributeData* attributeData = newData<specular__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPECULAR__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__specular__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__specular__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SPECULAR__TEXTURE = "specular__texture";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__specular__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__specular__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPECULAR__TEXTURE, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__specular__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__specular__texture( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHININESS = "shininess";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__SHININESS = "phong__shininess";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__shininess()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__shininess( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHININESS__FLOAT = "shininess__float";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shininess__float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    mStackMemoryManager.growObject(textLength);
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shininess__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shininess__float__AttributeData* attributeData = newData<shininess__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHININESS__FLOAT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shininess__float()
{
bool failed;
double parameter = GeneratedSaxParser::Utils::toDouble((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
    returnValue = mImpl->data__shininess__float(parameter);
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SHININESS__FLOAT, 0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shininess__float( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_SHININESS__PARAM = "shininess__param";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__shininess__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__shininess__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shininess__param__AttributeData* attributeData = newData<shininess__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHININESS__PARAM, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__shininess__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__shininess__param( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__REFLECTIVE = "phong__reflective";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__reflective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__REFLECTIVITY = "phong__reflectivity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__reflectivity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__TRANSPARENT = "phong__transparent";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__AttributeData* attributeData = newData<transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {
bool failed;
attributeData->opaque = Utils::toEnum<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(attributeValue, failed, fx_opaque_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHONG__TRANSPARENT, HASH_ATTRIBUTE_OPAQUE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHONG__TRANSPARENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__transparent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__TRANSPARENCY = "phong__transparency";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__transparency( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PHONG__INDEX_OF_REFRACTION = "phong__index_of_refraction";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__phong__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__phong__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__phong__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__phong__index_of_refraction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN = "blinn";

//---------------------------------------------------------------------
const char* NAME_ELEMENT_TECHNIQUE__BLINN = "technique__blinn";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__EMISSION = "blinn__emission";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__emission( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__AMBIENT = "blinn__ambient";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__ambient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__DIFFUSE = "blinn__diffuse";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__diffuse( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__SPECULAR = "blinn__specular";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__specular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__specular( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__SHININESS = "blinn__shininess";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__shininess()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__shininess( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__REFLECTIVE = "blinn__reflective";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__reflective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__REFLECTIVITY = "blinn__reflectivity";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__reflectivity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__TRANSPARENT = "blinn__transparent";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__AttributeData* attributeData = newData<transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {
bool failed;
attributeData->opaque = Utils::toEnum<fx_opaque_enum, StringHash, fx_opaque_enum__COUNT>(attributeValue, failed, fx_opaque_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLINN__TRANSPARENT, HASH_ATTRIBUTE_OPAQUE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLINN__TRANSPARENT, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__transparent( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__TRANSPARENCY = "blinn__transparency";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__transparency( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_BLINN__INDEX_OF_REFRACTION = "blinn__index_of_refraction";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__blinn__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__blinn__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__blinn__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__blinn__index_of_refraction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const char* NAME_ELEMENT_PROFILE_COMMON__EXTRA = "profile_COMMON__extra";

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_data__profile_COMMON__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON__EXTRA, 0, attributeValue))
            {return false;}
    }
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGenPrivate::_freeAttributes__profile_COMMON__extra( void* attributeData )
{
    return true;
}




}
